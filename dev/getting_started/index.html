<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started · Neuroblox</title><meta name="title" content="Getting Started · Neuroblox"/><meta property="og:title" content="Getting Started · Neuroblox"/><meta property="twitter:title" content="Getting Started · Neuroblox"/><meta name="description" content="Documentation for Neuroblox."/><meta property="og:description" content="Documentation for Neuroblox."/><meta property="twitter:description" content="Documentation for Neuroblox."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Neuroblox logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Neuroblox</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Neuroblox</a></li><li class="is-active"><a class="tocitem" href>Getting Started</a><ul class="internal"><li><a class="tocitem" href="#Example-1-:-Building-an-oscillating-circuit-from-two-Wilson-Cowan-Neural-Mass-Models"><span>Example 1 : Building an oscillating circuit from two Wilson-Cowan Neural Mass Models</span></a></li><li><a class="tocitem" href="#Example-2-:-Building-a-Brain-Circuit-from-literature-using-Neural-Mass-Models"><span>Example 2 : Building a Brain Circuit from literature using Neural Mass Models</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/resting_state_wb/">Tutorial on resting state simulation using neural mass models</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../release_notes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Neuroblox/Neuroblox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Neuroblox/Neuroblox.jl/blob/master/docs/src/getting_started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="neuroblox_example"><a class="docs-heading-anchor" href="#neuroblox_example">Getting Started with Neuroblox</a><a id="neuroblox_example-1"></a><a class="docs-heading-anchor-permalink" href="#neuroblox_example" title="Permalink"></a></h1><p>This tutorial will introduce you to simulating brain dynamics using Neuroblox.</p><h2 id="Example-1-:-Building-an-oscillating-circuit-from-two-Wilson-Cowan-Neural-Mass-Models"><a class="docs-heading-anchor" href="#Example-1-:-Building-an-oscillating-circuit-from-two-Wilson-Cowan-Neural-Mass-Models">Example 1 : Building an oscillating circuit from two Wilson-Cowan Neural Mass Models</a><a id="Example-1-:-Building-an-oscillating-circuit-from-two-Wilson-Cowan-Neural-Mass-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1-:-Building-an-oscillating-circuit-from-two-Wilson-Cowan-Neural-Mass-Models" title="Permalink"></a></h2><p>The Wilson–Cowan model describes the dynamics of interactions between populations of excitatory and inhibitory neurons. Each Wilson-Cowan Blox is described by the follwoing equations:</p><p class="math-container">\[\frac{dE}{dt} = \frac{-E}{\tau_E} + \frac{1}{1 + \text{exp}(-a_E*(c_{EE}*E - c_{IE}*I - \theta_E + \eta*(\sum{jcn}))}\\[10pt]
\frac{dI}{dt} = \frac{-I}{\tau_I} + \frac{1}{1 + exp(-a_I*(c_{EI}*E - c_{II}*I - \theta_I)}\]</p><p>Our first example is to simply combine two Wilson-Cowan Blox to build an oscillatory circuit</p><pre><code class="language-julia hljs">using Neuroblox
using DifferentialEquations
using Graphs
using MetaGraphs
using Plots

@named WC1 = WilsonCowan()
@named WC2 = WilsonCowan()

g = MetaDiGraph()
add_blox!.(Ref(g), [WC1, WC2])

adj = [-1 6; 6 -1]
create_adjacency_edges!(g, adj)</code></pre><p>First, we create the two Wilson-Cowan Blox: WC1 and WC2. Next, we add the two Blox into a directed graph as nodes and then we are creating weighted edges between the two nodes using an adjacency matrix.</p><p>Now we are ready to build the ModelingToolkit System.  Structural simplify creates the final set of equations in which all substiutions are made.</p><pre><code class="language-julia hljs">@named sys = system_from_graph(g)
sys = structural_simplify(sys)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} WC1_{+}E\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - WC1_{+}E\left( t \right)}{WC1_+\tau_{E}} + \frac{1}{1 + e^{ - WC1_{+}a_{E} \left(  - WC1_+\theta_{E} + WC1_{+}c_{EE} WC1_{+}E\left( t \right) - WC1_{+}c_{IE} WC1_{+}I\left( t \right) + WC1_+\eta WC1_{+}jcn\left( t \right) \right)}} \\
\frac{\mathrm{d} WC1_{+}I\left( t \right)}{\mathrm{d}t} =&amp; \frac{1}{1 + e^{ - WC1_{+}a_{I} \left(  - WC1_+\theta_{I} + WC1_{+}c_{EI} WC1_{+}E\left( t \right) - WC1_{+}c_{II} WC1_{+}I\left( t \right) \right)}} + \frac{ - WC1_{+}I\left( t \right)}{WC1_+\tau_{I}} \\
\frac{\mathrm{d} WC2_{+}E\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - WC2_{+}E\left( t \right)}{WC2_+\tau_{E}} + \frac{1}{1 + e^{ - WC2_{+}a_{E} \left(  - WC2_+\theta_{E} + WC2_{+}c_{EE} WC2_{+}E\left( t \right) - WC2_{+}c_{IE} WC2_{+}I\left( t \right) + WC2_+\eta WC2_{+}jcn\left( t \right) \right)}} \\
\frac{\mathrm{d} WC2_{+}I\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - WC2_{+}I\left( t \right)}{WC2_+\tau_{I}} + \frac{1}{1 + e^{ - WC2_{+}a_{I} \left(  - WC2_+\theta_{I} + WC2_{+}c_{EI} WC2_{+}E\left( t \right) - WC2_{+}c_{II} WC2_{+}I\left( t \right) \right)}}
\end{align}
 \]</p><p>To solve the system, we first create an ODEProblem and then solve it over the tspan of (0,100) using a stiff solver.  The solution is saved every 0.1ms. The unit of time in Neuroblox is 1ms.</p><pre><code class="language-julia hljs">prob = ODEProblem(sys, [], (0.0, 100), [])
sol = solve(prob, Rodas4(), saveat=0.1)
plot(sol)</code></pre><img src="a0d24927.svg" alt="Example block output"/><h2 id="Example-2-:-Building-a-Brain-Circuit-from-literature-using-Neural-Mass-Models"><a class="docs-heading-anchor" href="#Example-2-:-Building-a-Brain-Circuit-from-literature-using-Neural-Mass-Models">Example 2 : Building a Brain Circuit from literature using Neural Mass Models</a><a id="Example-2-:-Building-a-Brain-Circuit-from-literature-using-Neural-Mass-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2-:-Building-a-Brain-Circuit-from-literature-using-Neural-Mass-Models" title="Permalink"></a></h2><p>In this example, we will construct a Parkinsons model from eight Jansen-Rit Neural Mass Models as described in Liu et al. (2020). DOI: 10.1016/j.neunet.2019.12.021. The Jansen-Rit Neural Mass model is defined by the following differential equations:</p><p class="math-container">\[\frac{dx}{dt} = y-\frac{2}{\tau}x
\frac{dy}{dt} = -\frac{x}{\tau^2} + \frac{H}{\tau} [\frac{2\lambda}{1+\text{exp}(-r*\sum{jcn})} - \lambda]\]</p><pre><code class="language-julia hljs">using Neuroblox
using DifferentialEquations
using Graphs
using MetaGraphs
using Plots</code></pre><p>The original paper units are in seconds we therefore need to multiply all parameters with a common factor</p><pre><code class="language-julia hljs">τ_factor = 1000

@named Str = JansenRit(τ=0.0022*τ_factor, H=20/τ_factor, λ=300, r=0.3)
@named GPE = JansenRit(τ=0.04*τ_factor, cortical=false) # all default subcortical except τ
@named STN = JansenRit(τ=0.01*τ_factor, H=20/τ_factor, λ=500, r=0.1)
@named GPI = JansenRit(cortical=false) # default parameters subcortical Jansen Rit blox
@named Th  = JansenRit(τ=0.002*τ_factor, H=10/τ_factor, λ=20, r=5)
@named EI  = JansenRit(τ=0.01*τ_factor, H=20/τ_factor, λ=5, r=5)
@named PY  = JansenRit(cortical=true) # default parameters cortical Jansen Rit blox
@named II  = JansenRit(τ=2.0*τ_factor, H=60/τ_factor, λ=5, r=5)
blox = [Str, GPE, STN, GPI, Th, EI, PY, II]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{JansenRit}:
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x000000000000000d, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :Str, ODESystem[], Dict{Any, Any}(τ =&gt; 2.2, H =&gt; 0.02, x(t) =&gt; 1.0, λ =&gt; 300, r =&gt; 0.3, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x000000000000000e, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :GPE, ODESystem[], Dict{Any, Any}(τ =&gt; 40.0, H =&gt; 0.02, x(t) =&gt; 1.0, λ =&gt; 400.0, r =&gt; 0.1, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x000000000000000f, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :STN, ODESystem[], Dict{Any, Any}(τ =&gt; 10.0, H =&gt; 0.02, x(t) =&gt; 1.0, λ =&gt; 500, r =&gt; 0.1, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x0000000000000010, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :GPI, ODESystem[], Dict{Any, Any}(τ =&gt; 14, H =&gt; 0.02, x(t) =&gt; 1.0, λ =&gt; 400.0, r =&gt; 0.1, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x0000000000000011, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :Th, ODESystem[], Dict{Any, Any}(τ =&gt; 2.0, H =&gt; 0.01, x(t) =&gt; 1.0, λ =&gt; 20, r =&gt; 5, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x0000000000000012, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :EI, ODESystem[], Dict{Any, Any}(τ =&gt; 10.0, H =&gt; 0.02, x(t) =&gt; 1.0, λ =&gt; 5, r =&gt; 5, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x0000000000000013, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :PY, ODESystem[], Dict{Any, Any}(τ =&gt; 1, H =&gt; 0.02, x(t) =&gt; 1.0, λ =&gt; 5.0, r =&gt; 0.15, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)
 JansenRit(Any[τ, H, λ, r], x(t), jcn(t), ODESystem(0x0000000000000014, Equation[Differential(t)(x(t)) ~ y(t) + (-2x(t)) / τ, Differential(t)(y(t)) ~ (-x(t)) / (τ^2) + (H*((2λ) / (1 + exp(-r*jcn(t))) - λ)) / τ], t, SymbolicUtils.BasicSymbolic{Real}[x(t), y(t), jcn(t)], SymbolicUtils.BasicSymbolic{Real}[τ, H, λ, r], nothing, Dict{Any, Any}(:H =&gt; H, :y =&gt; y(t), :λ =&gt; λ, :τ =&gt; τ, :jcn =&gt; jcn(t), :r =&gt; r, :x =&gt; x(t)), Any[], Equation[], Base.RefValue{Vector{Num}}(Num[]), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Any}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), Base.RefValue{Matrix{Num}}(Matrix{Num}(undef, 0, 0)), :II, ODESystem[], Dict{Any, Any}(τ =&gt; 2000.0, H =&gt; 0.06, x(t) =&gt; 1.0, λ =&gt; 5, r =&gt; 5, jcn(t) =&gt; 0.0, y(t) =&gt; 1.0), Dict{Any, Any}(), nothing, nothing, Equation[], nothing, nothing, nothing, ModelingToolkit.SymbolicContinuousCallback[], ModelingToolkit.SymbolicDiscreteCallback[], nothing, nothing, nothing, nothing, nothing, false, nothing, nothing, nothing, nothing, nothing), nothing)</code></pre><p>Again, we create a graph and add the Blox as nodes</p><pre><code class="language-julia hljs">g = MetaDiGraph()
add_blox!.(Ref(g), blox)

params = @parameters C_Cor=60 C_BG_Th=60 C_Cor_BG_Th=5 C_BG_Th_Cor=5</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
C_{Cor} \\
C_{BG\_Th} \\
C_{Cor\_BG\_Th} \\
C_{BG\_Th\_Cor} \\
\end{array}
\right]
\end{equation}
 \]</p><p>ModelingToolkit allows us to create parameters that can be passed into the equations symbolically.</p><p>We add edges as specified in Table 2 of Liu et al. We only implemented a subset of the nodes and edges to describe a less complex version of the model. Edges can also be created using an adjacency matrix as in the previous example.</p><pre><code class="language-julia hljs">add_edge!(g, 2, 1, Dict(:weight =&gt; -0.5*C_BG_Th))
add_edge!(g, 2, 2, Dict(:weight =&gt; -0.5*C_BG_Th))
add_edge!(g, 2, 3, Dict(:weight =&gt; C_BG_Th))
add_edge!(g, 3, 2, Dict(:weight =&gt; -0.5*C_BG_Th))
add_edge!(g, 3, 7, Dict(:weight =&gt; C_Cor_BG_Th))
add_edge!(g, 4, 2, Dict(:weight =&gt; -0.5*C_BG_Th))
add_edge!(g, 4, 3, Dict(:weight =&gt; C_BG_Th))
add_edge!(g, 5, 4, Dict(:weight =&gt; -0.5*C_BG_Th))
add_edge!(g, 6, 5, Dict(:weight =&gt; C_BG_Th_Cor))
add_edge!(g, 6, 7, Dict(:weight =&gt; 6*C_Cor))
add_edge!(g, 7, 6, Dict(:weight =&gt; 4.8*C_Cor))
add_edge!(g, 7, 8, Dict(:weight =&gt; -1.5*C_Cor))
add_edge!(g, 8, 7, Dict(:weight =&gt; 1.5*C_Cor))
add_edge!(g, 8, 8, Dict(:weight =&gt; 3.3*C_Cor))
add_edge!(g,1,1,:weight, -0.5*C_BG_Th)
add_edge!(g,1,2,:weight, C_BG_Th)
add_edge!(g,2,1,:weight, -0.5*C_BG_Th)
add_edge!(g,2,5,:weight, C_Cor_BG_Th)
add_edge!(g,3,1,:weight, -0.5*C_BG_Th)
add_edge!(g,3,2,:weight, C_BG_Th)
add_edge!(g,4,3,:weight, -0.5*C_BG_Th)
add_edge!(g,4,4,:weight, C_BG_Th_Cor)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Now we are ready to build the ModelingToolkit System and apply structural simplification to the equations.</p><pre><code class="language-julia hljs">@named final_system = system_from_graph(g)
final_system_sys = structural_simplify(final_system)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} Str_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 Str_{+}x\left( t \right)}{Str_+\tau} + Str_{+}y\left( t \right) \\
\frac{\mathrm{d} Str_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - Str_{+}x\left( t \right)}{Str_+\tau^{2}} + \frac{Str_{+}H \left(  - Str_+\lambda + \frac{2 Str_+\lambda}{1 + e^{ - Str_{+}r Str_{+}jcn\left( t \right)}} \right)}{Str_+\tau} \\
\frac{\mathrm{d} GPE_{+}x\left( t \right)}{\mathrm{d}t} =&amp; GPE_{+}y\left( t \right) + \frac{ - 2 GPE_{+}x\left( t \right)}{GPE_+\tau} \\
\frac{\mathrm{d} GPE_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{GPE_{+}H \left(  - GPE_+\lambda + \frac{2 GPE_+\lambda}{1 + e^{ - GPE_{+}r GPE_{+}jcn\left( t \right)}} \right)}{GPE_+\tau} + \frac{ - GPE_{+}x\left( t \right)}{GPE_+\tau^{2}} \\
\frac{\mathrm{d} STN_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 STN_{+}x\left( t \right)}{STN_+\tau} + STN_{+}y\left( t \right) \\
\frac{\mathrm{d} STN_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{STN_{+}H \left(  - STN_+\lambda + \frac{2 STN_+\lambda}{1 + e^{ - STN_{+}r STN_{+}jcn\left( t \right)}} \right)}{STN_+\tau} + \frac{ - STN_{+}x\left( t \right)}{STN_+\tau^{2}} \\
\frac{\mathrm{d} GPI_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 GPI_{+}x\left( t \right)}{GPI_+\tau} + GPI_{+}y\left( t \right) \\
\frac{\mathrm{d} GPI_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - GPI_{+}x\left( t \right)}{GPI_+\tau^{2}} + \frac{GPI_{+}H \left(  - GPI_+\lambda + \frac{2 GPI_+\lambda}{1 + e^{ - GPI_{+}r GPI_{+}jcn\left( t \right)}} \right)}{GPI_+\tau} \\
\frac{\mathrm{d} Th_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 Th_{+}x\left( t \right)}{Th_+\tau} + Th_{+}y\left( t \right) \\
\frac{\mathrm{d} Th_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{Th_{+}H \left(  - Th_+\lambda + \frac{2 Th_+\lambda}{1 + e^{ - Th_{+}r Th_{+}jcn\left( t \right)}} \right)}{Th_+\tau} + \frac{ - Th_{+}x\left( t \right)}{Th_+\tau^{2}} \\
\frac{\mathrm{d} EI_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 EI_{+}x\left( t \right)}{EI_+\tau} + EI_{+}y\left( t \right) \\
\frac{\mathrm{d} EI_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - EI_{+}x\left( t \right)}{EI_+\tau^{2}} + \frac{EI_{+}H \left(  - EI_+\lambda + \frac{2 EI_+\lambda}{1 + e^{ - EI_{+}r EI_{+}jcn\left( t \right)}} \right)}{EI_+\tau} \\
\frac{\mathrm{d} PY_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 PY_{+}x\left( t \right)}{PY_+\tau} + PY_{+}y\left( t \right) \\
\frac{\mathrm{d} PY_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{PY_{+}H \left(  - PY_+\lambda + \frac{2 PY_+\lambda}{1 + e^{ - PY_{+}r PY_{+}jcn\left( t \right)}} \right)}{PY_+\tau} + \frac{ - PY_{+}x\left( t \right)}{PY_+\tau^{2}} \\
\frac{\mathrm{d} II_{+}x\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - 2 II_{+}x\left( t \right)}{II_+\tau} + II_{+}y\left( t \right) \\
\frac{\mathrm{d} II_{+}y\left( t \right)}{\mathrm{d}t} =&amp; \frac{ - II_{+}x\left( t \right)}{II_+\tau^{2}} + \frac{II_{+}H \left(  - II_+\lambda + \frac{2 II_+\lambda}{1 + e^{ - II_{+}r II_{+}jcn\left( t \right)}} \right)}{II_+\tau}
\end{align}
 \]</p><p>Our Jansen-Rit model allows delayed edges, and we therefore need to collect those delays (in our case all delays are zero).  Then we build a Delayed Differential Equations Problem (DDEProblem).</p><pre><code class="language-julia hljs">sim_dur = 1000.0 # Simulate for 1 second
prob = ODEProblem(final_system_sys,
    [],
    (0.0, sim_dur))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 1000.0)
u0: 16-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0</code></pre><p>We select an algorithm and solve the system</p><pre><code class="language-julia hljs">alg = Tsit5()
sol_dde_no_delays = solve(prob, alg, saveat=1)
plot(sol_dde_no_delays)</code></pre><img src="30657adf.svg" alt="Example block output"/><p>In a later tutorial, we will show how to introduce edge delays.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Neuroblox</a><a class="docs-footer-nextpage" href="../tutorials/resting_state_wb/">Tutorial on resting state simulation using neural mass models »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Friday 7 June 2024 16:59">Friday 7 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
