var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#v0.3","page":"Release Notes","title":"v0.3","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Initial Release!","category":"page"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Neuroblox]","category":"page"},{"location":"api/#Neuroblox.BalloonModel","page":"API","title":"Neuroblox.BalloonModel","text":"Arguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nlnκ: logarithmic prefactor to signal decay H[1], set to 0 for standard parameter value.\nlnτ: logarithmic prefactor to transit time H[3], set to 0 for standard parameter value.\nlnϵ: logarithm of ratio of intra- to extra-vascular signal\n\nNB: the prefix ln of the variables u, ν, q as well as the parameters κ, τ denotes their transformation into logarithmic space to enforce their positivity. This transformation is considered in the derivates of the model equations below. \n\nCitations:\n\nStephan K E, Weiskopf N, Drysdale P M, Robinson P A, and Friston K J. Comparing Hemodynamic Models with DCM. NeuroImage 38, no. 3 (2007): 387–401. doi: 10.1016/j.neuroimage.2007.07.040\nHofmann D, Chesebro A G, Rackauckas C, Mujica-Parodi L R, Friston K J, Edelman A, and Strey H H. Leveraging Julia's Automated Differentiation and Symbolic Computation to Increase Spectral DCM Flexibility and Speed, 2023. doi: 10.1101/2023.10.27.564407\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.Generic2dOscillator","page":"API","title":"Neuroblox.Generic2dOscillator","text":"Generic2dOscillator(name, namespace, ...)\n\nThe Generic2dOscillator model is a generic dynamic system with two state\nvariables. The dynamic equations of this model are composed of two ordinary\ndifferential equations comprising two nullclines. The first nullcline is a\ncubic function as it is found in most neuron and population models; the\nsecond nullcline is arbitrarily configurable as a polynomial function up to\nsecond order. The manipulation of the latter nullcline's parameters allows\nto generate a wide range of different behaviours.\n\nEquations:\n\n```math\n        \\begin{align}\n        \\dot{V} &= d \\, \\tau (-f V^3 + e V^2 + g V + \\alpha W + \\gamma I) \\\\\n        \\dot{W} &= \\dfrac{d}{\tau}\\,\\,(c V^2 + b V - \\beta W + a)\n        \\end{align}\n```\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOther parameters: See reference for full list. Note that parameters are scaled so that units of time are in milliseconds.\n\nCitations: FitzHugh, R., Impulses and physiological states in theoretical models of nerve membrane, Biophysical Journal 1: 445, 1961.\n\nNagumo et.al, An Active Pulse Transmission Line Simulating Nerve Axon, Proceedings of the IRE 50: 2061, 1962.\n\nStefanescu, R., Jirsa, V.K. Reduced representations of heterogeneous mixed neural networks with synaptic coupling. Physical Review E, 83, 2011.\n\nJirsa VK, Stefanescu R.  Neural population modes capture biologically realistic large-scale network dynamics. Bulletin of Mathematical Biology, 2010.\n\nStefanescu, R., Jirsa, V.K. A low dimensional description of globally coupled heterogeneous neural networks of excitatory and inhibitory neurons. PLoS Computational Biology, 4(11), 2008).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.HarmonicOscillator","page":"API","title":"Neuroblox.HarmonicOscillator","text":"HarmonicOscillator(name, namespace, ω, ζ, k, h)\n\nCreate a harmonic oscillator blox with the specified parameters.\nThe formal definition of this blox is:\n\nfracdxdt = y-(2*omega*zeta*x)+ k*(2pi)*(atan((sumjcn)h)\nfracdydt = -(omega^2)*x\n\nwhere ``jcn`` is any input to the blox.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nω: Base frequency. Note the default value is scaled to give oscillations in milliseconds to match other blocks.\nζ: Damping ratio.\nk: Gain.\nh: Threshold.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.JansenRit","page":"API","title":"Neuroblox.JansenRit","text":"JansenRit(name, namespace, τ, H, λ, r, cortical, delayed)\n\nCreate a Jansen Rit blox as described in Liu et al.\nThe formal definition of this blox is:\n\nfracdxdt = y-frac2taux\nfracdydt = -fracxtau^2 + fracHtau frac2lambda1+textexp(-r*sumjcn) - lambda\n\nwhere jcn is any input to the blox.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nτ: Time constant. This is changed from the original source as the time constant was in seconds, while all our blocks are in milliseconds.\nH: See equation for use.\nλ: See equation for use.\nr: See equation for use.\ncortical: Boolean to determine whether to use cortical or subcortical parameters. Specifying any of the parameters above will override this.\ndelayed: Boolean to indicate whether states are delayed\n\nCitations:\n\nLiu C, Zhou C, Wang J, Fietkiewicz C, Loparo KA. The role of coupling connections in a model of the cortico-basal ganglia-thalamocortical neural loop for the generation of beta oscillations. Neural Netw. 2020 Mar;123:381-392. doi: 10.1016/j.neunet.2019.12.021.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.JansenRitSPM12","page":"API","title":"Neuroblox.JansenRitSPM12","text":"Jansen-Rit model block for canonical micro circuit, analogous to the implementation in SPM12\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.KuramotoOscillator","page":"API","title":"Neuroblox.KuramotoOscillator","text":"KuramotoOscillator(name, namespace, ...)\n\nSimple implementation of the Kuramoto oscillator as described in the original paper [1].\nUseful for general models of synchronization and oscillatory behavior.\nThe general form of the Kuramoto oscillator is given by:\nEquations:\n\n```math\n        \\begin{equation}\n        \\dot{\\theta_i} = \\omega_i + \\frac{1}{N}\\sum_{j=1}^N{K_{i, j}\\text{sin}(\\theta_j - \\theta_i)}\n        \\end{equation}\n```\n\nWhere this describes the connection between regions $i$ and $j$. An alternative form\nwhich includes a noise term for each region is also provided, taking the form:\n\n```math\n        \\begin{equation}\n        \\dot{\\theta_i} = \\omega_i + \\zeta dW_i \\frac{1}{N}\\sum_{j=1}^N{K_{i, j}\\text{sin}(\\theta_j - \\theta_i)}\n        \\end{equation}\n```\n\nwhere $W_i$ is a Wiener process and $\\zeta_i$ is the noise strength.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOther parameters: See reference for full list. Note that parameters are scaled so that units of time are in milliseconds.                   Default parameter values are taken from [2].\n\nCitations:\n\nKuramoto, Y. (1975). Self-entrainment of a population of coupled non-linear oscillators.  In: Araki, H. (eds) International Symposium on Mathematical Problems in Theoretical Physics.  Lecture Notes in Physics, vol 39. Springer, Berlin, Heidelberg. https://doi.org/10.1007/BFb0013365\nSermon JJ, Wiest C, Tan H, Denison T, Duchet B. Evoked resonant neural activity long-term  dynamics can be reproduced by a computational model with vesicle depletion. Neurobiol Dis.  2024 Jun 14;199:106565. doi: 10.1016/j.nbd.2024.106565. Epub ahead of print. PMID: 38880431.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.LarterBreakspear","page":"API","title":"Neuroblox.LarterBreakspear","text":"LarterBreakspear(name, namespace, ...)\n\nCreate a Larter Breakspear blox described in Endo et al. For a full list of the parameters used see the reference.\nIf you need to modify the parameters, see Chesebro et al. and van Nieuwenhuizen et al. for physiological ranges.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOther parameters: See reference for full list. Note that parameters are scaled so that units of time are in milliseconds.\n\nCitations:\n\nEndo H, Hiroe N, Yamashita O. Evaluation of Resting Spatio-Temporal Dynamics of a Neural Mass Model Using Resting fMRI Connectivity and EEG Microstates. Front Comput Neurosci. 2020 Jan 17;13:91. doi: 10.3389/fncom.2019.00091.\nChesebro AG, Mujica-Parodi LR, Weistuch C. Ion gradient-driven bifurcations of a multi-scale neuronal model. Chaos Solitons Fractals. 2023 Feb;167:113120. doi: 10.1016/j.chaos.2023.113120. \nvan Nieuwenhuizen, H, Chesebro, AG, Polis, C, Clarke, K, Strey, HH, Weistuch, C, Mujica-Parodi, LR. Ketosis regulates K+ ion channels, strengthening brain-wide signaling disrupted by age. Preprint. bioRxiv 2023.05.10.540257; doi: https://doi.org/10.1101/2023.05.10.540257. \n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.OUBlox","page":"API","title":"Neuroblox.OUBlox","text":"Ornstein-Uhlenbeck process Blox\n\nvariables:     x(t):  value     jcn:   input  parameters:     τ:      relaxation time \tμ:      average value \tσ:      random noise (variance of OU process is τ*σ^2/2) returns:     an ODE System (but with brownian parameters)\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.Striatum","page":"API","title":"Neuroblox.Striatum","text":"Subcortical blox\nall subcprtical blox used in cortico-striatal model are defined here\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.WilsonCowan","page":"API","title":"Neuroblox.WilsonCowan","text":"WilsonCowan(name, namespace, τ_E, τ_I, a_E, a_I, c_EE, c_IE, c_EI, c_II, θ_E, θ_I, η)\n\nCreate a standard Wilson Cowan blox.\nThe formal definition of this blox is:\n\nfracdEdt = frac-Etau_E + frac11 + textexp(-a_E*(c_EE*E - c_IE*I - theta_E + eta*(sumjcn))\nfracdIdt = frac-Itau_I + frac11 + exp(-a_I*(c_EI*E - c_II*I - theta_I)\n\nwhere jcn is any input to the blox.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOthers: See equation for use.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.WinnerTakeAllBlox","page":"API","title":"Neuroblox.WinnerTakeAllBlox","text":"WinnerTakeAllBlox\n\nCreates a winner-take-all local circuit found in neocortex, typically 5 pyramidal (excitatory) neurons send synapses to a single interneuron (inhibitory) and receive feedback inhibition from that interneuron.\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.eigen-Union{Tuple{Array{ForwardDiff.Dual{T, P, np}, 2}}, Tuple{np}, Tuple{P}, Tuple{T}} where {T, P, np}","page":"API","title":"LinearAlgebra.eigen","text":"function LinearAlgebra.eigen(M::Matrix{Dual{T, P, np}}) where {T, P, np}\n\nDispatch of LinearAlgebra.eigen for dual matrices with complex numbers. Make the eigenvalue decomposition \namenable to automatic differentiation. To do so compute the analytical derivative of eigenvalues\nand eigenvectors. \n\nArguments:\n- `M`: matrix of type Dual of which to compute the eigenvalue decomposition. \n\nReturns:\n- `Eigen(evals, evecs)`: eigenvalue decomposition returned as type LinearAlgebra.Eigen\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.ARVTarget-NTuple{6, Any}","page":"API","title":"Neuroblox.ARVTarget","text":"ARVTarget Time series data is bandpass filtered and then the power spectrum is computed for a given time interval (control bin), returned as the average value of the power spectral density within a certain frequency band ([lb, ub]).\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.CDVTarget-NTuple{5, Any}","page":"API","title":"Neuroblox.CDVTarget","text":"CDVTarget Time series data is bandpass filtered and hilbert-transformed. Phase angle is computed in radians. Circular difference is quantified as the angle of circular_location.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.ControlError-NTuple{8, Any}","page":"API","title":"Neuroblox.ControlError","text":"ControlError Returns the control error (deviation of the actual value from the target value).\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.PDVTarget-NTuple{5, Any}","page":"API","title":"Neuroblox.PDVTarget","text":"PDVTarget Time series data is bandpass filtered and hilbert-transformed. Phase angle is computed in radians. Phase deviation is quantified as the angle difference between a given set of signals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.PLVTarget-NTuple{6, Any}","page":"API","title":"Neuroblox.PLVTarget","text":"PLVTarget Time series data is bandpass filtered and hilbert-transformed. Phase angle is computed in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.addnontunableparams-Tuple{Any, Any}","page":"API","title":"Neuroblox.addnontunableparams","text":"function addnontunableparams(param, model)\n\nFunction adds parameters of a model that were not marked as tunable to a list of tunable parameters\nand respects the MTK ordering of parameters.\n\nArguments:\n- `paramlist`: parameters of an MTK system that were tagged as tunable\n- `sys`: MTK system\n\nReturns:\n- `completeparamlist`: complete parameter list of a system, including those that were not tagged as tunable\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.bandpassfilter-Tuple{}","page":"API","title":"Neuroblox.bandpassfilter","text":"bandpassfilter takes in time series data and bandpass filters it. It has the following inputs:     data: time series data     lb: minimum cut-off frequency     ub: maximum cut-off frequency     fs: sampling frequency     order: filter order\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.boldsignal-Tuple{}","page":"API","title":"Neuroblox.boldsignal","text":"Arguments:\n\nname: Name given to ODESystem object within the blox.\nlnϵ  : logarithm of ratio of intra- to extra-vascular signal\n\nNB: the prefix ln of the variables ν, q as well as the parameters ϵ denotes their transformation into logarithmic space to enforce their positivity.\n\nCitations:\n\nStephan K E, Weiskopf N, Drysdale P M, Robinson P A, and Friston K J. Comparing Hemodynamic Models with DCM. NeuroImage 38, no. 3 (2007): 387–401. doi: 10.1016/j.neuroimage.2007.07.040\nHofmann D, Chesebro A G, Rackauckas C, Mujica-Parodi L R, Friston K J, Edelman A, and Strey H H. Leveraging Julia's Automated Differentiation and Symbolic Computation to Increase Spectral DCM Flexibility and Speed, 2023. doi: 10.1101/2023.10.27.564407\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.complexwavelet","page":"API","title":"Neuroblox.complexwavelet","text":"complexwavelet creates a complex morlet wavelet by windowing a complex sine wave with a Gaussian taper.  The morlet wavelet is a special case of a bandpass filter in which the frequency response is Gaussian-shaped. Convolution with a complex wavelet is equivalent to performing a Hilbert transform of a bandpass filtered signal.\n\nIt has the following inputs:     data: time series data      dt  : data sampling rate      lb  : lower bound wavelet frequency (in Hz)     ub  : upper bound wavelet frequency (in Hz)     a   : amplitude of the Gaussian taper, default is 1     n   : number of wavelet cycles of the Gaussian taper, defines the trade-off between temporal precision and frequency precision           larger n gives better frequency precision at the cost of temporal precision           default is 6 Hz     m   : x-axis offset, default is 0     num_wavelets : number of wavelets to create, default is 5\n\nAnd outputs:     complex_wavelet : a family of complex morlet wavelets\n\n\n\n\n\n","category":"function"},{"location":"api/#Neuroblox.csd2mar-NTuple{4, Any}","page":"API","title":"Neuroblox.csd2mar","text":"This function converts a cross-spectral density (CSD) into a multivariate auto-regression (MAR) model. It first transforms the CSD into its cross-correlation function (Wiener-Kinchine theorem) and then computes the MAR model coefficients. csd       : cross-spectral density matrix of size MxN; M: number of samples, N: number of cross-spectral dimensions (number of variables squared) w         : frequencies dt        : time step size p         : number of time steps of auto-regressive model\n\nThis function returns coeff     : array of length p of coefficient matrices of size sqrt(N)xsqrt(N) noise_cov : noise covariance matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.csd_approx-NTuple{4, Any}","page":"API","title":"Neuroblox.csd_approx","text":"This function implements equation 2 of the spectral DCM paper, Friston et al. 2014 \"A DCM for resting state fMRI\".\nNote that nomenclature is taken from SPM12 code and it does not seem to coincide with the spectral DCM paper's nomenclature. \nFor instance, Gu should represent the spectral component due to external input according to the paper. However, in the code this represents\nthe hidden state fluctuations (which are called Gν in the paper).\nGn in the code corresponds to Ge in the paper, i.e. the observation noise. In the code global and local components are defined, no such distinction\nis discussed in the paper. In fact the parameter γ, corresponding to local component is not present in the paper.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.get_dynamic_states-Tuple{Any}","page":"API","title":"Neuroblox.get_dynamic_states","text":"function get_dynamic_states(sys)\n\nFunction extracts states from the system that are dynamic variables, \nget also indices of external inputs (u(t)) and measurements (like bold(t))\nArguments:\n- `sys`: MTK system\n\nReturns:\n- `sts`: states/unknowns of the system that are neither external inputs nor measurements, i.e. these are the dynamic states\n- `idx`: indices of these states\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.get_input_equations-Tuple{Union{Neuroblox.AbstractBlox, Neuroblox.ObserverBlox}}","page":"API","title":"Neuroblox.get_input_equations","text":"Returns the equations for all input variables of a system, \nassuming they have a form like : `sys.input_variable ~ ...`\nso only the input appears on the LHS.\n\nInput equations are namespaced by the inner namespace of blox\nand then they are returned. This way during system `compose` downstream,\nthe higher-level namespaces will be added to them.\n\nIf blox isa AbstractComponent, it is assumed that it contains a `connector` field,\nwhich holds a `BloxConnector` object with all relevant connections \nfrom lower levels and this level.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.idft-Tuple{AbstractArray}","page":"API","title":"Neuroblox.idft","text":"Plain implementation of idft because AD dispatch versions for ifft don't work still!\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.inner_namespaceof-Tuple{Any}","page":"API","title":"Neuroblox.inner_namespaceof","text":"Returns the complete namespace EXCLUDING the outermost (highest) level.\nThis is useful for manually preparing equations (e.g. connections, see BloxConnector),\nthat will later be composed and will automatically get the outermost namespace.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.learningrate-Tuple{Any, Any}","page":"API","title":"Neuroblox.learningrate","text":"This function computes learning rate. It has the following inputs:     outcomes: vector of 1's and 0's for behavioral outcomes     windows: number of windows to split the outcome data into And the following outputs:     rate: the learning rate across each window\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.mar2csd-Tuple{Any, Any, Any}","page":"API","title":"Neuroblox.mar2csd","text":"This function converts multivariate auto-regression (MAR) model parameters to a cross-spectral density (CSD). A     : coefficients of MAR model, array of length p, each element contains the regression coefficients for that particular time-lag. Σ     : noise covariance matrix of MAR p     : number of time lags freqs : frequencies at which to evaluate the CSD sf    : sampling frequency\n\nThis function returns: csd   : cross-spectral density matrix of size MxN; M: number of samples, N: number of cross-spectral dimensions (number of variables squared)\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.mar_ml-Tuple{Any, Any}","page":"API","title":"Neuroblox.mar_ml","text":"Maximum likelihood estimator of a multivariate, or vector auto-regressive model.     y : MxN Data matrix where M is number of samples and N is number of dimensions     p : time lag parameter, also called order of MAR model     return values     mar[\"A\"] : model parameters is a NxNxP tensor, i.e. one NxN parameter matrix for each time bin k ∈ {1,...,p}     mar[\"Σ\"] : noise covariance matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.matlab_norm-Tuple{Any, Any}","page":"API","title":"Neuroblox.matlab_norm","text":"function matlab_norm(A, p)\n\nSimple helper function to implement the norm of a matrix that is equivalent to the one given in MATLAB for order=1, 2, Inf. \nThis is needed for the reproduction of the exact same results of SPM12.\n\nArguments:\n- `A`: matrix\n- `p`: order of norm\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.params-Tuple{Neuroblox.BloxConnector}","page":"API","title":"Neuroblox.params","text":"Helper to merge delays and weights into a single vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.paramscoping-Tuple{}","page":"API","title":"Neuroblox.paramscoping","text":"function paramscoping(;kwargs...)\n\nScope arguments that are already a symbolic model parameter thereby keep the correct namespace \nand make those that are not yet symbolic a symbol.\nKeyword arguments are used, because parameter definition require names, not just values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phase_cos_blox-Union{Tuple{F}, Tuple{Any, Any, F}} where F","page":"API","title":"Neuroblox.phase_cos_blox","text":"phasecosblox is creating a cos with angular frequency ω and variable phase phaseinter has the following parameters:     ω: angular frequency     t: time     phaseinter: a function that returns phase as a function of time and returns:     the resulting value\n\nUsage:     phaseint = phaseinter(0:0.1:50,phasedata)     phaseout(t) = phasecosblox(0.1,t,phaseint)     which is now a function of time and can be used in an input blox     you can also use the dot operator to calculate time-series     signal = phaseout.(collect(0:0.01:50))\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phase_inter-Tuple{Any, Any}","page":"API","title":"Neuroblox.phase_inter","text":"phaseinter is creating a function that interpolates the phase data for any time given phaseinter has the following parameters:     phaserange:  a range, e.g. 0:0.1:50 which should reflect the time points of the data     phasedata: phase at equidistant time points and returns:     an function that returns an interpolated phase for t in range\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phase_sin_blox-Union{Tuple{F}, Tuple{Any, Any, F}} where F","page":"API","title":"Neuroblox.phase_sin_blox","text":"phasesinblox is creating a sin with angular frequency ω and variable phase phaseinter has the following parameters:     ω: angular frequency     t: time     phaseinter: a function that returns phase as a function of time and returns:     the resulting value\n\nUsage:     phaseint = phaseinter(0:0.1:50,phasedata)     phaseout(t) = phasesinblox(0.1,t,phaseint)     which is now a function of time and can be used in an input blox     you can also use the dot operator to calculate time-series     signal = phaseout.(collect(0:0.01:50))\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phaseangle-Tuple{}","page":"API","title":"Neuroblox.phaseangle","text":"phaseangle takes in time series data, hilbert transforms it, and estimates the phase angle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.random_initials-Tuple{ODESystem, Any}","page":"API","title":"Neuroblox.random_initials","text":"random_initials creates a vector of random initial conditions for an ODESystem that is composed of a list of blox.  The function finds the initial conditions in the blox and then sets a random value in between range tuple given for that state.\n\nIt has the following inputs:     odesys: ODESystem     blox  : list of blox\n\nAnd outputs:     u0 : Float64 vector of initial conditions\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.sample_affect!-NTuple{4, Any}","page":"API","title":"Neuroblox.sample_affect!","text":"Non-symbolic, time-block-based way of `@register_symbolic sample_poisson(λ)`.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.setup_sDCM-NTuple{9, Any}","page":"API","title":"Neuroblox.setup_sDCM","text":"function setup_sDCM(data, stateevolutionmodel, initcond, csdsetup, priors, hyperpriors, indices)\n\nInterface function to performs variational inference to fit model parameters to empirical cross spectral density.\nThe current implementation provides a Variational Laplace fit (see function above `variationalbayes`).\n\nArguments:\n- `data`        : dataframe with column names corresponding to the regions of measurement.\n- `model`       : MTK model, including state evolution and measurement.\n- `initcond`    : dictionary of initial conditions, numerical values for all states\n- `csdsetup`    : dictionary of parameters required for the computation of the cross spectral density\n-- `dt`         : sampling interval\n-- `freq`       : frequencies at which to evaluate the CSD\n-- `p`          : order parameter of the multivariate autoregression model\n- `priors`      : dataframe of parameters with the following columns:\n-- `name`       : corresponds to MTK model name\n-- `mean`       : corresponds to prior mean value\n-- `variance`   : corresponds to the prior variances\n- `hyperpriors` : dataframe of parameters with the following columns:\n-- `Πλ_pr`      : prior precision matrix for λ hyperparameter(s)\n-- `μλ_pr`      : prior mean(s) for λ hyperparameter(s)\n- `indices`  : indices to separate model parameters from other parameters. Needed for the computation of AD gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.spm_logdet-Tuple{Any}","page":"API","title":"Neuroblox.spm_logdet","text":"function spm_logdet(M)\n\nSPM12 style implementation of the logarithm of the determinant of a matrix.\n\nArguments:\n- `M`: matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.system_from_graph","page":"API","title":"Neuroblox.system_from_graph","text":"system_from_graph(g::MetaDiGraph, p=Num[]; name, simplify=true, graphdynamics=false, kwargs...)\n\nTake in a MetaDiGraph g describing a network of neural structures (and optionally a vector of extra parameters p) and construct a System which can be used to construct various Problem types (i.e. ODEProblem) for use with DifferentialEquations.jl solvers.\n\nIf simplify is set to true (the default), then the resulting system will have structural_simplify called on it with any remaining keyword arguments forwared to structural_simplify. That is,\n\n@named sys = system_from_graph(g; kwarg1=x, kwarg2=y)\n\nis equivalent to\n\n@named sys = system_from_graph(g; simplify=false)\nsys = structural_simplify(sys; kwarg1=x, kwarg2=y)\n\nSee the docstring for structural_simplify for information on which options it supports.\n\nIf graphdynamics=true (defaults to false), the output will be a GraphSystem from GraphDynamics.jl, and the kwargs will be sent to the GraphDynamics constructor instead of using ModelingToolkit.jl. The GraphDynamics.jl backend is typically significantly faster for large neural systems than the default backend, but is experimental and does not yet support all Neuroblox.jl features. \n\n\n\n\n\n","category":"function"},{"location":"api/#Neuroblox.vecparam-Tuple{OrderedCollections.OrderedDict}","page":"API","title":"Neuroblox.vecparam","text":"vecparam(param::OrderedDict)\n\nFunction to flatten an ordered dictionary of model parameters and return a simple list of parameter values.\n\nArguments:\n- `param`: dictionary of model parameters (may contain numbers and lists of numbers)\n\n\n\n\n\n","category":"method"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"getting_started.jl\"","category":"page"},{"location":"getting_started/#Getting-Started-with-Neuroblox","page":"Getting Started","title":"Getting Started with Neuroblox","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial will introduce you to simulating brain dynamics using Neuroblox. In this example, we'll create a simple oscillating circuit using two Wilson-Cowan neural mass models [1]. The Wilson-Cowan model is one of the most influential models in computational neuroscience [2], describing the dynamics of interactions between populations of excitatory and inhibitory neurons.","category":"page"},{"location":"getting_started/#The-Wilson-Cowan-Model","page":"Getting Started","title":"The Wilson-Cowan Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Each Wilson-Cowan neural mass is described by the following equations:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"beginalign\nnonumber\nfracdEdt = frac-Etau_E + S_E(c_EEE - c_IEI + etatextstylesumjcn)10pt\nnonumber\nfracdIdt = frac-Itau_I + S_Ileft(c_EIE - c_IIIright)\nendalign","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"where E and I denote the activity levels of the excitatory and inhibitory populations, respectively. The terms fracdEdt and fracdIdt describe the rate of change of these activity levels over time. The parameters tau_E and tau_I are time constants analogous to membrane time constants in single neuron models, determining how quickly the excitatory and inhibitory populations respond to changes. The coefficients c_EE and c_II represent self-interaction (or feedback) within excitatory and inhibitory populations, while c_IE and c_EI represent the cross-interactions between the two populations. The term etasumjcn represents external input to the excitatory population from other brain regions or external stimuli, with eta acting as a scaling factor. While S_E and S_I are sigmoid functions that represent the responses of neuronal populations to input stimuli, defined as:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"S_k(x) = frac11 + exp(-a_kx - theta_k)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"where a_k and theta_k determine the steepness and threshold of the response, respectively.","category":"page"},{"location":"getting_started/#Building-the-Circuit","page":"Getting Started","title":"Building the Circuit","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's create an oscillating circuit by connecting two Wilson-Cowan neural masses:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Neuroblox\nusing DifferentialEquations\nusing CairoMakie\n\n# Create two Wilson-Cowan blox\n@named WC1 = WilsonCowan()\n@named WC2 = WilsonCowan()\n\n# Create a graph to represent our circuit\ng = MetaDiGraph()\nadd_blox!.(Ref(g), [WC1, WC2])\n\n# Define the connectivity between the neural masses\nadd_edge!(g, WC1 => WC1; weight = -1) ## recurrent connection from WC1 to itself\nadd_edge!(g, WC1 => WC2; weight = 7) ## connection from WC1 to WC2\nadd_edge!(g, WC2 => WC1; weight = 4) ## connection from WC2 to WC1\nadd_edge!(g, WC2 => WC2; weight = -1) ## recurrent connection from WC2 to itself","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here, we've created two Wilson-Cowan Blox and connected them as nodes in a directed graph. The adj matrix defines the weighted edges between these nodes. Each entry adj[i,j] represents how the output of blox j influences the input of blox i:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Diagonal elements (adj[1,1] and adj[2,2]): Self-connections, adding feedback to each blox.\nOff-diagonal elements (adj[1,2] and adj[2,1]): Inter-blox connections, determining how each blox influences the other.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"By default, the output of each Wilson-Cowan blox is its excitatory activity (E). The negative self-connections (-1) provide inhibitory feedback, while the positive inter-blox connections (6) provide strong excitatory coupling. This setup creates an oscillatory dynamic between the two Wilson-Cowan units.","category":"page"},{"location":"getting_started/#Creating-the-Model","page":"Getting Started","title":"Creating the Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, let's build the complete model:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@named sys = system_from_graph(g)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This creates a differential equations system from our graph representation using ModelingToolkit and symbolically simplifies it for efficient computation.","category":"page"},{"location":"getting_started/#Simulating-the-Model","page":"Getting Started","title":"Simulating the Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We are now ready to simulate our model. The following code creates and solves an ODEProblem for our system, simulating 100 time units of activity. In Neuroblox, the default time unit is milliseconds. We use Rodas4, a solver efficient for stiff problems. The solution is saved every 0.1 ms, allowing us to observe the detailed evolution of the system's behavior.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"prob = ODEProblem(sys, [], (0.0, 100), [])\nsol = solve(prob, Rodas4(), saveat=0.1)","category":"page"},{"location":"getting_started/#Plotting-simulation-results","page":"Getting Started","title":"Plotting simulation results","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, let us plot the E and I states of the first component, WC1.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"E1 = state_timeseries(WC1, sol, \"E\")\nI1 = state_timeseries(WC1, sol, \"I\")\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time (ms)\")\nlines!(ax, sol.t, E1, label = \"E\")\nlines!(ax, sol.t, I1, label = \"I\")\nLegend(fig[1,2], ax)\nfig","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[1] Wilson, H. R., & Cowan, J. D. (1972). Excitatory and inhibitory interactions in localized populations of model neurons. Biophysical journal, 12(1), 1-24.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[2] Destexhe, A., & Sejnowski, T. J. (2009). The Wilson–Cowan model, 36 years later. Biological cybernetics, 101(1), 1-2.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"EditURL = \"parkinsons.jl\"","category":"page"},{"location":"tutorials/parkinsons/#Building-a-model-of-Parkinson's-disease-using-Neural-Mass-models","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"In this example, we'll construct a model of Parkinson's disease using eight Jansen-Rit Neural Mass Models, based on the work of Liu et al. (2020) [1].","category":"page"},{"location":"tutorials/parkinsons/#The-Jansen-Rit-Neural-Mass-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"The Jansen-Rit Neural Mass Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"The Jansen-Rit model [2] is another popular neural mass model that, like the Wilson-Cowan model from Example 1, describes the average activity of neural populations. Each Jansen-Rit unit is defined by the following differential equations:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"beginalign\nfracdxdt = y-frac2taux 10pt\nfracdydt = -fracxtau^2 + fracHtau left2lambda S(textstylesumjcn) - lambdaright\nendalign","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"where x represents the average postsynaptic membrane potential of the neural population, y is an auxiliary variable, tau is the membrane time constant, H is the maximum postsynaptic potential amplitude, lambda determines the maximum firing rate, and sumjcn represents the sum of all synaptic inputs to the population. The sigmoid function S(x) models the population's firing rate response to input and is defined as:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"S(x) = frac11 + textexp(-rx)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"where r controls the steepness of the sigmoid, affecting the population's sensitivity to input.","category":"page"},{"location":"tutorials/parkinsons/#Setting-Up-the-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Setting Up the Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Let's start by importing the necessary libraries and defining our neural masses:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"using Neuroblox\nusing DifferentialEquations\nusing CairoMakie\n\n# Convert time units from seconds to milliseconds\nτ_factor = 1000\n\n# Define Jansen-Rit neural masses for different brain regions\n@named Str = JansenRit(τ=0.0022*τ_factor, H=20/τ_factor, λ=300, r=0.3)\n@named GPE = JansenRit(τ=0.04*τ_factor, cortical=false)  # all default subcortical except τ\n@named STN = JansenRit(τ=0.01*τ_factor, H=20/τ_factor, λ=500, r=0.1)\n@named GPI = JansenRit(cortical=false)  # default parameters subcortical Jansen Rit blox\n@named Th  = JansenRit(τ=0.002*τ_factor, H=10/τ_factor, λ=20, r=5)\n@named EI  = JansenRit(τ=0.01*τ_factor, H=20/τ_factor, λ=5, r=5)\n@named PY  = JansenRit(cortical=true)  # default parameters cortical Jansen Rit blox\n@named II  = JansenRit(τ=2.0*τ_factor, H=60/τ_factor, λ=5, r=5)\n\nblox = [Str, GPE, STN, GPI, Th, EI, PY, II]\n\n\n#Here, we've created eight Jansen-Rit neural masses representing different brain regions involved in Parkinson's disease. The `τ_factor` is used to convert time units from seconds (as in the original paper) to milliseconds (Neuroblox's default time unit).","category":"page"},{"location":"tutorials/parkinsons/#Building-the-Circuit","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building the Circuit","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Now, let's create a graph representing our brain circuit:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"g = MetaDiGraph()\nadd_blox!.(Ref(g), blox)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"We've created a MetaDiGraph and added our neural masses as nodes. Next, we'll define the connections between these nodes based on the known anatomy of the basal ganglia-thalamocortical circuit.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"ModelingToolkit allows us to create parameters that can be passed into the equations symbolically:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"As an alternative to creating edges with an adjacency matrix (as shown in the previous example), here we demonstrate a different approach by adding edges one by one. In this case, we set the connections specified in Table 2 of Liu et al. [1], although we only implement a subset of the nodes and edges to describe a simplified version of the model:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"# Define connection strength parameters\nparams = @parameters C_Cor=60 C_BG_Th=60 C_Cor_BG_Th=5 C_BG_Th_Cor=5\n\nadd_edge!(g, 2, 1, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 2, 2, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 2, 3, Dict(:weight => C_BG_Th))\nadd_edge!(g, 3, 2, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 3, 7, Dict(:weight => C_Cor_BG_Th))\nadd_edge!(g, 4, 2, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 4, 3, Dict(:weight => C_BG_Th))\nadd_edge!(g, 5, 4, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 6, 5, Dict(:weight => C_BG_Th_Cor))\nadd_edge!(g, 6, 7, Dict(:weight => 6*C_Cor))\nadd_edge!(g, 7, 6, Dict(:weight => 4.8*C_Cor))\nadd_edge!(g, 7, 8, Dict(:weight => -1.5*C_Cor))\nadd_edge!(g, 8, 7, Dict(:weight => 1.5*C_Cor))\nadd_edge!(g, 8, 8, Dict(:weight => 3.3*C_Cor))\nadd_edge!(g,1,1,:weight, -0.5*C_BG_Th)\nadd_edge!(g,1,2,:weight, C_BG_Th)\nadd_edge!(g,2,1,:weight, -0.5*C_BG_Th)\nadd_edge!(g,2,5,:weight, C_Cor_BG_Th)\nadd_edge!(g,3,1,:weight, -0.5*C_BG_Th)\nadd_edge!(g,3,2,:weight, C_BG_Th)\nadd_edge!(g,4,3,:weight, -0.5*C_BG_Th)\nadd_edge!(g,4,4,:weight, C_BG_Th_Cor)","category":"page"},{"location":"tutorials/parkinsons/#Creating-the-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Creating the Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Let's build the complete model:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"@named final_system = system_from_graph(g)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"This creates a differential equations system from our graph representation using ModelingToolkit and symbolically simplifies it for efficient computation.","category":"page"},{"location":"tutorials/parkinsons/#Simulating-the-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Simulating the Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Lastly, we create the ODEProblem for our system, select an algorithm, in this case Tsit5(), and simulate 1 second of brain activity.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"sim_dur = 1000.0 # Simulate for 1 second\nprob = ODEProblem(final_system, [], (0.0, sim_dur))\nsol = solve(prob, Tsit5(), saveat=1)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"[1] Liu, C., Zhou, C., Wang, J., Fietkiewicz, C., & Loparo, K. A. (2020). The role of coupling connections in a model of the cortico-basal ganglia-thalamocortical neural loop for the generation of beta oscillations. Neural Networks, 123, 381-392.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"EditURL = \"neural_assembly.jl\"","category":"page"},{"location":"tutorials/neural_assembly/#Tutorial-on-bottom-up-approach-to-building-a-neural-assembly","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"","category":"section"},{"location":"tutorials/neural_assembly/#Single-spiking-neuron-from-Hodgkin-Huxley-model","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Single spiking neuron from Hodgkin-Huxley model","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig1)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Hodgkin-Huxley (HH) formalism to describe membrane potential of a single neuron","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"  beginalign\n  C_mfracdVdt = -g_L(V-V_L) - g_Nam^3h(V-V_Na) -g_Kn^4(V-V_K) + I_in - I_syn \n  fracdmdt = alpha_m(V)(1-m) + beta_m(V)m \n  fracdhdt = alpha_h(V)(1-h) + beta_h(V)h \n  fracdndt = alpha_n(V)(1-n) + beta_n(V)n\n  endalign","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"using Neuroblox\nusing DifferentialEquations ## to build the ODE problem and solve it, gain access to multiple solvers from this\nusing Random ## for generating random variables\nusing CairoMakie ## for customized plotting recipies for blox\nusing CSV ## to read data from CSV files\nusing DataFrames ## to format the data into DataFrames","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"define a single excitatory neuron 'blox' with steady input current I_bg = 0.5 microA/cm2","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"nn1 = HHNeuronExciBlox(name=Symbol(\"nrn1\"), I_bg=0.5)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"define graph and add the single neuron 'blox' as a single node into the graph","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"g = MetaDiGraph() ## defines a graph\nadd_blox!.(Ref(g), [nn1]) ## adds the defined blocks into the graph","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"create an ODESystem from the graph","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"@named sys = system_from_graph(g)\nlength(unknowns(sys)) ## shows the number of variables in the simplified system","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"To solve the system, we first create an Ordinary Differential Equation Problem and then solve it over the tspan of (0,1e) using a Vern7() solver.  The solution is saved every 0.1ms. The unit of time in Neuroblox is 1ms.","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"prob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"acessing the voltage timeseries from the neuron block and plotting the voltage","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"v = voltage_timeseries(nn1, sol)\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Voltage (mv)\")\nlines!(ax, sol.t, v)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Suggestion : Try different values of input current 'I_bg' and run the entire code block to see the output activity","category":"page"},{"location":"tutorials/neural_assembly/#Connecting-three-neurons-through-synapses-to-make-a-local-feed-forward-circuit","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Connecting three neurons through synapses to make a local feed-forward circuit","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig2)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"# While creating a system of multiple components (neurons in this case), each component should be defined within the same namespace. So first\n# we define a global namespace.\nglobal_namespace=:g\n\n# define three neurons, two excitatory and one inhibitory\n\nnn1 = HHNeuronExciBlox(name=Symbol(\"nrn1\"), I_bg=0.4,namespace=global_namespace)\nnn2 = HHNeuronInhibBlox(name=Symbol(\"nrn2\"), I_bg=0.1,namespace=global_namespace)\nnn3 = HHNeuronExciBlox(name=Symbol(\"nrn3\"), I_bg=1.4,namespace=global_namespace)\n\n# defien graph and connect the nodes with the edges (synapses in this case), with the synaptic 'weights' specified as arguments\ng = MetaDiGraph()\nadd_edge!(g, nn1 => nn2, weight = 1) ##connection from neuron 1 to neuron 2 (nn1 to nn2)\nadd_edge!(g, nn2 => nn3, weight = 0.2) ##connection from neuron 2 to neuron 3 (nn2 to nn3)\nadd_edge!(g, nn1 => nn3, weight = 0.5) ##connection from neuron 1 to neuron 3 (nn2 to nn3)\n\n# create an ODESystem from the graph and then solve it using an ODE solver\n@named sys = system_from_graph(g)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1);\n\n# plotting membrane voltage activity of all neurons in a stacked form\n\nstackplot([nn1,nn2,nn3],sol)\t## stackplot(<blox or array of blox>, sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Suggestion : Try different values of input currents 'I_bg' and connection weights. One can try different permutations of excitatory and inhibitory neurons.","category":"page"},{"location":"tutorials/neural_assembly/#Creating-a-lateral-inhibition-circuit-(the-\"winner-takes-all\"-circuit)-in-superficial-cortical-layer","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating a lateral inhibition circuit (the \"winner-takes-all\" circuit) in superficial cortical layer","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig3)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\nN_exci = 5; ##number of excitatory neurons\n\nn_inh = HHNeuronInhibBlox(name = Symbol(\"inh\"), namespace=global_namespace, G_syn = 4.0, τ = 70) ##feedback inhibitory interneuron neuron\n\n##creating an array of excitatory pyramidal neurons\nn_excis = [HHNeuronExciBlox(\n                            name = Symbol(\"exci$i\"),\n                            namespace=global_namespace,\n                            G_syn = 3.0,\n                            τ = 5,\n                            I_bg = 5*rand(),\n                            ) for i = 1:N_exci]\n\ng = MetaDiGraph()\n\nfor i in Base.OneTo(N_exci)\n    add_edge!(g, n_inh => n_excis[i], weight = 1.0)\n    add_edge!(g, n_excis[i] => n_inh, weight = 1.0)\nend\n\n@named sys = system_from_graph(g)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1)\nstackplot(vcat(n_excis,n_inh),sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Suggestion : Instead of uniform random input current in each excitatory neuron, try different configurations (random or constant) of input currents I_bg for each neuron. One can vary the size of circuit by changing number of excitatory neurons.","category":"page"},{"location":"tutorials/neural_assembly/#Creating-lateral-inhibition-\"winner-take-all\"-circuit-(WTA)-blocks-from-the-inbuilt-functions-and-connecting-two-WTA-circuit-blocks","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating lateral inhibition \"winner-take-all\" circuit (WTA) blocks from the inbuilt functions and connecting two WTA circuit blocks","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\nN_exci = 5 ##number of excitatory neurons in each WTA circuit\nwta1 = WinnerTakeAllBlox(name=Symbol(\"wta1\"), I_bg=5.0, N_exci=N_exci, namespace=global_namespace) ##for a single valued input current, each neuron of the WTA circuit will recieve a uniformly distributed random input from 0 to I_bg\nwta2 = WinnerTakeAllBlox(name=Symbol(\"wta2\"), I_bg=4.0, N_exci=N_exci, namespace=global_namespace)\n\ng = MetaDiGraph()\nadd_edge!(g, wta1 => wta2, weight=1, density=0.5) ##density keyword sets the connection probability from each excitatory neuron of source WTA circuit to each excitatory neuron of target WTA circuit\n\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1)\n\nvoltage_stack([wta1,wta2],sol)","category":"page"},{"location":"tutorials/neural_assembly/#Creating-a-single-cortical-superficial-layer-block-(SCORT-in-Pathak-et.-al.-2024)-by-connecting-multiple-WTA-circuits","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating a single cortical superficial layer block (SCORT in Pathak et. al. 2024) by connecting multiple WTA circuits","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig4)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\nN_wta=10 ## number of WTA circuits\n# parameters\nN_exci=5   ##number of pyramidal neurons in each lateral inhibition (WTA) circuit\nG_syn_exci=3.0 ##maximal synaptic conductance in glutamatergic (excitatory) synapses\nG_syn_inhib=4.0 ## maximal synaptic conductance in GABAergic (inhibitory) synapses from feedback interneurons\nG_syn_ff_inhib=3.5 ## maximal synaptic conductance in GABAergic (inhibitory) synapses from feedforward interneurons\nI_bg=5.0 ##background input\ndensity=0.01 ##connection density between WTA circuits\n\n##creating array of WTA ciruits\nwtas = [WinnerTakeAllBlox(;\n                           name=Symbol(\"wta$i\"),\n                           namespace=global_namespace,\n                           N_exci=N_exci,\n                           G_syn_exci=G_syn_exci,\n                           G_syn_inhib=G_syn_inhib,\n                           I_bg = I_bg\n                          ) for i = 1:N_wta]\n\n##feed-forward interneurons (get input from other pyramidal cells and from the ascending system, largely controls the rhythm)\nn_ff_inh = HHNeuronInhibBlox(;\n                             name=Symbol(\"ff_inh\"),\n                             namespace=global_namespace,\n                             G_syn=G_syn_ff_inhib\n                            )\n\ng = MetaDiGraph()\n\n# connecting WTA circuits to each other with given connection density, and feedforward interneuron connects to each WTA circuit\nfor i in 1:N_wta\n    for j in 1:N_wta\n        if j != i\n            add_edge!(g, wtas[i] => wtas[j], weight=1, density=density)\n        end\n    end\n    add_edge!(g, n_ff_inh => wtas[i], weight=1)\nend\n\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1)\n\nstackplot(vcat(wtas, n_ff_inh),sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Sugestion : try different connection densities and weights and see how it affects the population activity.","category":"page"},{"location":"tutorials/neural_assembly/#Creating-an-ascending-system-block-(ASC1-in-Pathak-et.-al.-2024),-a-single-inbuilt-cortical-superficial-layer-block-(SCORT-in-Pathak-et.-al.-2024)-and-connecting-them.","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating an ascending system block (ASC1 in Pathak et. al. 2024), a single inbuilt cortical superficial layer block (SCORT in Pathak et. al. 2024) and connecting them.","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\n\n# define ascending system block using a Next Generation Neural Mass model as described in Byrne et. al. 2020.\n# the parameters are fixed to generate a 16 Hz modulating frequency in the cortical neurons\n@named ASC1 = NextGenerationEIBlox(;namespace=global_namespace, Cₑ=2*26,Cᵢ=1*26, Δₑ=0.5, Δᵢ=0.5, η_0ₑ=10.0, η_0ᵢ=0.0, v_synₑₑ=10.0, v_synₑᵢ=-10.0, v_synᵢₑ=10.0, v_synᵢᵢ=-10.0, alpha_invₑₑ=10.0/26, alpha_invₑᵢ=0.8/26, alpha_invᵢₑ=10.0/26, alpha_invᵢᵢ=0.8/26, kₑₑ=0.0*26, kₑᵢ=0.6*26, kᵢₑ=0.6*26, kᵢᵢ=0*26)\n\n# define the superficial layer cortical block using inbuilt function\n# Number if WTA circuits = N_wta=45; number of pyramidal neurons in each WTA circuit = N_exci = 5;\n@named CB = CorticalBlox(N_wta=10, N_exci=5, density=0.01, weight=1,I_bg_ar=7;namespace=global_namespace)\n\n# define graph and connect ASC1->CB\ng = MetaDiGraph()\nadd_edge!(g, ASC1 => CB, weight=44)\n\n# solve the system for time 0 to 1000 ms\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), []) ## tspan = (0,1000)\nsol = solve(prob, Vern7(), saveat=0.1);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot neuron time series","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"neuron_set = get_neurons(CB) ## extract neurons from a composite block like CorticalBlox\nn_neurons = 50 ## set number nof neurons to display in the stackplot\nstackplot(neuron_set[1:n_neurons],sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot the meanfield of all cortical block neurons (mean membrane voltage)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"mnv = meanfield_timeseries(CB, sol)\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Meanfield voltage (mv)\")\nlines!(ax, sol.t, mnv)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot power spectrum of the meanfield (average over membrane potentials)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"powerspectrumplot(CB,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Notice the peak at 16 Hz, representing beta oscillations. Sugestion : try changing parameters of ASC1 to generate different cortical rhythms. See how the peak shifts in the powerspectrum","category":"page"},{"location":"tutorials/neural_assembly/#Creating-simulation-of-visual-stimulus-response-in-cortical-blocks","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating simulation of visual stimulus response in cortical blocks","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig5) create cortical blocks for visual area cortex (VAC), anterior cortex (AC) and ascending system block (ASC1)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\n# cortical blox\n@named VAC = CorticalBlox(N_wta=10, N_exci=5,  density=0.01, weight=1,I_bg_ar=0;namespace=global_namespace)\n@named AC = CorticalBlox(N_wta=10, N_exci=5, density=0.01, weight=1,I_bg_ar=0;namespace=global_namespace)\n# ascending system blox, modulating frequency set to 16 Hz\n@named ASC1 = NextGenerationEIBlox(;namespace=global_namespace, Cₑ=2*26,Cᵢ=1*26, Δₑ=0.5, Δᵢ=0.5, η_0ₑ=10.0, η_0ᵢ=0.0, v_synₑₑ=10.0, v_synₑᵢ=-10.0, v_synᵢₑ=10.0, v_synᵢᵢ=-10.0, alpha_invₑₑ=10.0/26, alpha_invₑᵢ=0.8/26, alpha_invᵢₑ=10.0/26, alpha_invᵢᵢ=0.8/26, kₑₑ=0.0*26, kₑᵢ=0.6*26, kᵢₑ=0.6*26, kᵢᵢ=0*26)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"create an image source block which takes image data from a .csv file and gives input to visual cortex","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"fn = joinpath(@__DIR__, \"../data/image_example.csv\") ## image data file\nimage_set = CSV.read(fn, DataFrame) ## reading data into DataFrame format\nimage_sample = 11 ## set which image to input (from 1 to 1000)\n\n# define stimulus source blox\n# t_stimulus: how long the stimulus is on (in msec)\n# t_pause : how long th estimulus is off (in msec)\n@named stim = ImageStimulus(image_set[[image_sample],:]; namespace=global_namespace, t_stimulus=1000, t_pause=0);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot the image that the visual cortex 'sees'","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"pixels=Array(image_set[image_sample,1:end-1])## access the desired image sample from respective row\npixels=reshape(pixels,15,15)## reshape into 15 X 15 square image matrix\nheatmap(pixels,colormap = :gray1) #input image matrix seen as heatmap","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"assemble the blox into a graph and set connections with their keword arguments like connection weight and connection density","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"g = MetaDiGraph()\n\nadd_edge!(g, stim => VAC, weight=14)\nadd_edge!(g, ASC1 => VAC, weight=44)\nadd_edge!(g, ASC1 => AC, weight=44)\nadd_edge!(g, VAC => AC, weight=3, density=0.08)\n\n# define odesystem and solve\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), []) ## tspan = (0,1000)\nsol = solve(prob, Vern7(), saveat=0.1);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Let us now plot neuron potentials, meanfield activity and powerspectrums for the VAC and AC blox. First we show the stackplot of voltage potentials from the first 10 neurons of VAC","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"VAC_neuron_set = get_neurons(VAC) ## extract neurons from VAC\nn_neurons = 10\nstackplot(VAC_neuron_set[1:n_neurons],sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"then we plot the meanfield potential out of all neurons within VAC","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"mnv = meanfield_timeseries(VAC, sol)\n\nfig = Figure();\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Voltage (mv)\")\nlines!(ax, sol.t, mnv)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Here is the powerspectrum from all neurons within VAC","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"powerspectrumplot(VAC,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Moving on to the AC blox, we first plot the voltage potential of its neurons","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"AC_neuron_set = get_neurons(AC) ## extract neurons from VAC\nn_neurons = 10\nstackplot(AC_neuron_set[1:n_neurons],sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"followed by the meanfield activity","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"mnv = meanfield_timeseries(AC,sol)\nfig = Figure();\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Voltage (mv)\")\nlines!(ax, sol.t, mnv)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"and finally the AC powerspectrum","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"powerspectrumplot(AC,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Sugestion : Try changing the image samples and notice the change in the spatial firing patterns in VAC and AC neurons. One can make multiple cortical blocks simillar to AC and connect them in various connection topologies. All of them can directly or indirectly get input from VAC.","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Neuroblox","page":"Neuroblox","title":"Neuroblox","text":"","category":"section"},{"location":"#About","page":"Neuroblox","title":"About","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"Neuroblox.jl is designed for computational neuroscience and psychiatry applications. Our tools range from control circuit system identification to brain circuit simulations bridging scales from spiking neurons to fMRI-derived circuits, parameter-fitting models to neuroimaging data, interactions between the brain and other physiological systems, experimental optimization, and scientific machine learning.","category":"page"},{"location":"#Description","page":"Neuroblox","title":"Description","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"Neuroblox.jl is based on a library of modular computational building blocks (“blox”) in the form of systems of symbolic dynamic differential equations that can be combined to describe large-scale brain dynamics.  Once a model is built, it can be simulated efficiently and fit electrophysiological and neuroimaging data.  Moreover, the circuit behavior of multiple model variants can be investigated to aid in distinguishing between competing hypotheses. We employ ModelingToolkit.jl to describe the dynamical behavior of blox as symbolic (stochastic/delay) differential equations.  Our libraries of modular blox consist of individual neurons (Hodgkin-Huxley, IF, QIF, LIF, etc.), neural mass models (Jansen-Rit, Wilson-Cowan, Lauter-Breakspear, Next Generation, microcanonical circuits etc.) and biomimetically-constrained control circuit elements.  A GUI designed to be intuitive to neuroscientists allows researchers to build models that automatically generate high-performance systems of numerical ordinary/stochastic differential equations from which one can run stimulations with parameters fit to experimental data.  Our benchmarks show that the increase in speed for simulation often exceeds a factor of 100 as compared to neural mass model implementation by the Virtual Brain (python) and similar packages in MATLAB.  For parameter fitting of brain circuit dynamical models, we use Turing.jl to perform probabilistic modeling, including Hamilton-Monte-Carlo sampling and Automated Differentiation Variational Inference.","category":"page"},{"location":"#Installation","page":"Neuroblox","title":"Installation","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"To install Neuroblox.jl, first add the JuliaHubRegistry and then use the Julia package manager:","category":"page"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"using Pkg\nPkg.add(\"PkgAuthentication\")\nusing PkgAuthentication\nPkgAuthentication.install(\"juliahub.com\")\nPkg.Registry.add()\nPkg.add(\"Neuroblox\")","category":"page"},{"location":"#Licensing","page":"Neuroblox","title":"Licensing","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"Neuroblox is free for non-commerical and academic use. For full details of the license, please see  the Neuroblox EULA. For commercial use, get in contact with sales@neuroblox.org.","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"EditURL = \"resting_state.jl\"","category":"page"},{"location":"tutorials/resting_state/#Resting-state-simulation-using-neural-mass-models","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"","category":"section"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"This tutorial will introduce you to simulating resting state brain dynamics using Neuroblox. We will be using the FitzHugh-Nagumo model as a building block. The FitzHugh-Nagumo model is described by the follwoing equations:","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"       beginalign\n       dotV = d  tau (-f V^3 + e V^2 + alpha W - gamma I_c + sigma w(t) ) \n       dotW = dfracdtau(b V - beta W + a + sigma w(t) )\n       endalign","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"We start by building the resting state circuit from individual Generic2dOscillator Blox","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"using Neuroblox\nusing CSV\nusing DataFrames\nusing DifferentialEquations\nusing Random\nusing CairoMakie\nusing Statistics\nusing HypothesisTests\n\n# read connection matrix from file\nweights = CSV.read(\"../data/weights.csv\",DataFrame)\nregion_names = names(weights)\n\nwm = Array(weights) ## transform the weights into a matrix\nN_bloxs = size(wm)[1] ## number of blox components\n\n# create an array of neural mass models\nblocks = [Generic2dOscillator(name=Symbol(region_names[i]),bn=sqrt(5e-4)) for i in 1:N_bloxs]\n\n# add neural mass models to Graph and connect using the connection matrix\ng = MetaDiGraph()\nadd_blox!.(Ref(g), blocks)\ncreate_adjacency_edges!(g, wm)\n\n@named sys = system_from_graph(g);\nnothing #hide","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"To solve the system, we first create an Stochastic Differential Equation Problem and then solve it using a EulerHeun solver. The solution is saved every 0.5 ms. The unit of time in Neuroblox is 1 ms.","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"prob = SDEProblem(sys,rand(-2:0.1:4,76*2), (0.0, 6e5), [])\nsol = solve(prob, EulerHeun(), dt=0.5, saveat=5)","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"Let us plot the voltage potential of the first couple of components","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"v1 = voltage_timeseries(blocks[1], sol)\nv2 = voltage_timeseries(blocks[2], sol)\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Potential\")\nlines!(ax, sol.t, v1)\nlines!(ax, sol.t, v2)\nxlims!(ax, (0, 1000)) ## limit the x-axis to the first second of simulation\nfig","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"To evaluate the connectivity of our simulated resting state network, we calculate the statistically significant correlations","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"cs = []\nfor i in 1:Int((length(sol.t)-1)/1000)-1\n    solv = Array(sol[1:2:end,(i-1)*1000+1:(i*1000)])'\n    push!(cs,cor(solv))\nend\ncss = stack(cs)\n\np = zeros(76,76)\nfor i in 1:76\n    for j in 1:76\n        p[i,j] = pvalue(OneSampleTTest(css[i,j,:]))\n    end\nend\n\nheatmap(log10.(p) .* (p .< 0.05))","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"Fig.: log10(p value) displaying statistally significant correlation between time series","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"heatmap(wm)","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"Fig.: Connection Adjacency Matrix that was used to connect the neural mass models","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"This page was generated using Literate.jl.","category":"page"}]
}
