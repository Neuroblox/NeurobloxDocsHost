var documenterSearchIndex = {"docs":
[{"location":"release_notes/#Release-Notes","page":"Release Notes","title":"Release Notes","text":"","category":"section"},{"location":"release_notes/#v0.3","page":"Release Notes","title":"v0.3","text":"","category":"section"},{"location":"release_notes/","page":"Release Notes","title":"Release Notes","text":"Initial Release!","category":"page"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Neuroblox]","category":"page"},{"location":"api/#Neuroblox.BalloonModel","page":"API","title":"Neuroblox.BalloonModel","text":"Arguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nlnκ: logarithmic prefactor to signal decay H[1], set to 0 for standard parameter value.\nlnτ: logarithmic prefactor to transit time H[3], set to 0 for standard parameter value.\nlnϵ: logarithm of ratio of intra- to extra-vascular signal\n\nNB: the prefix ln of the variables u, ν, q as well as the parameters κ, τ denotes their transformation into logarithmic space to enforce their positivity. This transformation is considered in the derivates of the model equations below. \n\nCitations:\n\nStephan K E, Weiskopf N, Drysdale P M, Robinson P A, and Friston K J. Comparing Hemodynamic Models with DCM. NeuroImage 38, no. 3 (2007): 387–401. doi: 10.1016/j.neuroimage.2007.07.040\nHofmann D, Chesebro A G, Rackauckas C, Mujica-Parodi L R, Friston K J, Edelman A, and Strey H H. Leveraging Julia's Automated Differentiation and Symbolic Computation to Increase Spectral DCM Flexibility and Speed, 2023. doi: 10.1101/2023.10.27.564407\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.Generic2dOscillator","page":"API","title":"Neuroblox.Generic2dOscillator","text":"Generic2dOscillator(name, namespace, ...)\n\nThe Generic2dOscillator model is a generic dynamic system with two state\nvariables. The dynamic equations of this model are composed of two ordinary\ndifferential equations comprising two nullclines. The first nullcline is a\ncubic function as it is found in most neuron and population models; the\nsecond nullcline is arbitrarily configurable as a polynomial function up to\nsecond order. The manipulation of the latter nullcline's parameters allows\nto generate a wide range of different behaviours.\n\nEquations:\n\n```math\n        \\begin{align}\n        \\dot{V} &= d \\, \\tau (-f V^3 + e V^2 + g V + \\alpha W + \\gamma I) \\\\\n        \\dot{W} &= \\dfrac{d}{\tau}\\,\\,(c V^2 + b V - \\beta W + a)\n        \\end{align}\n```\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOther parameters: See reference for full list. Note that parameters are scaled so that units of time are in milliseconds.\n\nCitations: FitzHugh, R., Impulses and physiological states in theoretical models of nerve membrane, Biophysical Journal 1: 445, 1961.\n\nNagumo et.al, An Active Pulse Transmission Line Simulating Nerve Axon, Proceedings of the IRE 50: 2061, 1962.\n\nStefanescu, R., Jirsa, V.K. Reduced representations of heterogeneous mixed neural networks with synaptic coupling. Physical Review E, 83, 2011.\n\nJirsa VK, Stefanescu R.  Neural population modes capture biologically realistic large-scale network dynamics. Bulletin of Mathematical Biology, 2010.\n\nStefanescu, R., Jirsa, V.K. A low dimensional description of globally coupled heterogeneous neural networks of excitatory and inhibitory neurons. PLoS Computational Biology, 4(11), 2008).\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.HarmonicOscillator","page":"API","title":"Neuroblox.HarmonicOscillator","text":"HarmonicOscillator(name, namespace, ω, ζ, k, h)\n\nCreate a harmonic oscillator blox with the specified parameters.\nThe formal definition of this blox is:\n\nfracdxdt = y-(2*omega*zeta*x)+ k*(2pi)*(atan((sumjcn)h)\nfracdydt = -(omega^2)*x\n\nwhere ``jcn`` is any input to the blox.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nω: Base frequency. Note the default value is scaled to give oscillations in milliseconds to match other blocks.\nζ: Damping ratio.\nk: Gain.\nh: Threshold.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.JansenRit","page":"API","title":"Neuroblox.JansenRit","text":"JansenRit(name, namespace, τ, H, λ, r, cortical, delayed)\n\nCreate a Jansen Rit blox as described in Liu et al.\nThe formal definition of this blox is:\n\nfracdxdt = y-frac2taux\nfracdydt = -fracxtau^2 + fracHtau frac2lambda1+textexp(-r*sumjcn) - lambda\n\nwhere jcn is any input to the blox.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nτ: Time constant. This is changed from the original source as the time constant was in seconds, while all our blocks are in milliseconds.\nH: See equation for use.\nλ: See equation for use.\nr: See equation for use.\ncortical: Boolean to determine whether to use cortical or subcortical parameters. Specifying any of the parameters above will override this.\ndelayed: Boolean to indicate whether states are delayed\n\nCitations:\n\nLiu C, Zhou C, Wang J, Fietkiewicz C, Loparo KA. The role of coupling connections in a model of the cortico-basal ganglia-thalamocortical neural loop for the generation of beta oscillations. Neural Netw. 2020 Mar;123:381-392. doi: 10.1016/j.neunet.2019.12.021.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.JansenRitSPM12","page":"API","title":"Neuroblox.JansenRitSPM12","text":"Jansen-Rit model block for canonical micro circuit, analogous to the implementation in SPM12\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.KuramotoOscillator","page":"API","title":"Neuroblox.KuramotoOscillator","text":"KuramotoOscillator(name, namespace, ...)\n\nSimple implementation of the Kuramoto oscillator as described in the original paper [1].\nUseful for general models of synchronization and oscillatory behavior.\nThe general form of the Kuramoto oscillator is given by:\nEquations:\n\n```math\n        \\begin{equation}\n        \\dot{\\theta_i} = \\omega_i + \\frac{1}{N}\\sum_{j=1}^N{K_{i, j}\\text{sin}(\\theta_j - \\theta_i)}\n        \\end{equation}\n```\n\nWhere this describes the connection between regions $i$ and $j$. An alternative form\nwhich includes a noise term for each region is also provided, taking the form:\n\n```math\n        \\begin{equation}\n        \\dot{\\theta_i} = \\omega_i + \\zeta dW_i \\frac{1}{N}\\sum_{j=1}^N{K_{i, j}\\text{sin}(\\theta_j - \\theta_i)}\n        \\end{equation}\n```\n\nwhere $W_i$ is a Wiener process and $\\zeta_i$ is the noise strength.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOther parameters: See reference for full list. Note that parameters are scaled so that units of time are in milliseconds.                   Default parameter values are taken from [2].\n\nCitations:\n\nKuramoto, Y. (1975). Self-entrainment of a population of coupled non-linear oscillators.  In: Araki, H. (eds) International Symposium on Mathematical Problems in Theoretical Physics.  Lecture Notes in Physics, vol 39. Springer, Berlin, Heidelberg. https://doi.org/10.1007/BFb0013365\nSermon JJ, Wiest C, Tan H, Denison T, Duchet B. Evoked resonant neural activity long-term  dynamics can be reproduced by a computational model with vesicle depletion. Neurobiol Dis.  2024 Jun 14;199:106565. doi: 10.1016/j.nbd.2024.106565. Epub ahead of print. PMID: 38880431.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.LarterBreakspear","page":"API","title":"Neuroblox.LarterBreakspear","text":"LarterBreakspear(name, namespace, ...)\n\nCreate a Larter Breakspear blox described in Endo et al. For a full list of the parameters used see the reference.\nIf you need to modify the parameters, see Chesebro et al. and van Nieuwenhuizen et al. for physiological ranges.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOther parameters: See reference for full list. Note that parameters are scaled so that units of time are in milliseconds.\n\nCitations:\n\nEndo H, Hiroe N, Yamashita O. Evaluation of Resting Spatio-Temporal Dynamics of a Neural Mass Model Using Resting fMRI Connectivity and EEG Microstates. Front Comput Neurosci. 2020 Jan 17;13:91. doi: 10.3389/fncom.2019.00091.\nChesebro AG, Mujica-Parodi LR, Weistuch C. Ion gradient-driven bifurcations of a multi-scale neuronal model. Chaos Solitons Fractals. 2023 Feb;167:113120. doi: 10.1016/j.chaos.2023.113120. \nvan Nieuwenhuizen, H, Chesebro, AG, Polis, C, Clarke, K, Strey, HH, Weistuch, C, Mujica-Parodi, LR. Ketosis regulates K+ ion channels, strengthening brain-wide signaling disrupted by age. Preprint. bioRxiv 2023.05.10.540257; doi: https://doi.org/10.1101/2023.05.10.540257. \n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.OUBlox","page":"API","title":"Neuroblox.OUBlox","text":"Ornstein-Uhlenbeck process Blox\n\nvariables:     x(t):  value     jcn:   input  parameters:     τ:      relaxation time \tμ:      average value \tσ:      random noise (variance of OU process is τ*σ^2/2) returns:     an ODE System (but with brownian parameters)\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.Striatum","page":"API","title":"Neuroblox.Striatum","text":"Subcortical blox\nall subcprtical blox used in cortico-striatal model are defined here\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.WilsonCowan","page":"API","title":"Neuroblox.WilsonCowan","text":"WilsonCowan(name, namespace, τ_E, τ_I, a_E, a_I, c_EE, c_IE, c_EI, c_II, θ_E, θ_I, η)\n\nCreate a standard Wilson Cowan blox.\nThe formal definition of this blox is:\n\nfracdEdt = frac-Etau_E + frac11 + textexp(-a_E*(c_EE*E - c_IE*I - theta_E + eta*(sumjcn))\nfracdIdt = frac-Itau_I + frac11 + exp(-a_I*(c_EI*E - c_II*I - theta_I)\n\nwhere jcn is any input to the blox.\n\nArguments:\n\nname: Name given to ODESystem object within the blox.\nnamespace: Additional namespace above name if needed for inheritance.\nOthers: See equation for use.\n\n\n\n\n\n","category":"type"},{"location":"api/#Neuroblox.WinnerTakeAllBlox","page":"API","title":"Neuroblox.WinnerTakeAllBlox","text":"WinnerTakeAllBlox\n\nCreates a winner-take-all local circuit found in neocortex, typically 5 pyramidal (excitatory) neurons send synapses to a single interneuron (inhibitory) and receive feedback inhibition from that interneuron.\n\n\n\n\n\n","category":"type"},{"location":"api/#LinearAlgebra.eigen-Union{Tuple{Array{ForwardDiff.Dual{T, P, np}, 2}}, Tuple{np}, Tuple{P}, Tuple{T}} where {T, P, np}","page":"API","title":"LinearAlgebra.eigen","text":"function LinearAlgebra.eigen(M::Matrix{Dual{T, P, np}}) where {T, P, np}\n\nDispatch of LinearAlgebra.eigen for dual matrices with complex numbers. Make the eigenvalue decomposition \namenable to automatic differentiation. To do so compute the analytical derivative of eigenvalues\nand eigenvectors. \n\nArguments:\n- `M`: matrix of type Dual of which to compute the eigenvalue decomposition. \n\nReturns:\n- `Eigen(evals, evecs)`: eigenvalue decomposition returned as type LinearAlgebra.Eigen\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.ARVTarget-NTuple{6, Any}","page":"API","title":"Neuroblox.ARVTarget","text":"ARVTarget Time series data is bandpass filtered and then the power spectrum is computed for a given time interval (control bin), returned as the average value of the power spectral density within a certain frequency band ([lb, ub]).\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.CDVTarget-NTuple{5, Any}","page":"API","title":"Neuroblox.CDVTarget","text":"CDVTarget Time series data is bandpass filtered and hilbert-transformed. Phase angle is computed in radians. Circular difference is quantified as the angle of circular_location.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.ControlError-NTuple{8, Any}","page":"API","title":"Neuroblox.ControlError","text":"ControlError Returns the control error (deviation of the actual value from the target value).\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.PDVTarget-NTuple{5, Any}","page":"API","title":"Neuroblox.PDVTarget","text":"PDVTarget Time series data is bandpass filtered and hilbert-transformed. Phase angle is computed in radians. Phase deviation is quantified as the angle difference between a given set of signals.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.PLVTarget-NTuple{6, Any}","page":"API","title":"Neuroblox.PLVTarget","text":"PLVTarget Time series data is bandpass filtered and hilbert-transformed. Phase angle is computed in radians.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.addnontunableparams-Tuple{Any, Any}","page":"API","title":"Neuroblox.addnontunableparams","text":"function addnontunableparams(param, model)\n\nFunction adds parameters of a model that were not marked as tunable to a list of tunable parameters\nand respects the MTK ordering of parameters.\n\nArguments:\n- `paramlist`: parameters of an MTK system that were tagged as tunable\n- `sys`: MTK system\n\nReturns:\n- `completeparamlist`: complete parameter list of a system, including those that were not tagged as tunable\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.bandpassfilter-Tuple{}","page":"API","title":"Neuroblox.bandpassfilter","text":"bandpassfilter takes in time series data and bandpass filters it. It has the following inputs:     data: time series data     lb: minimum cut-off frequency     ub: maximum cut-off frequency     fs: sampling frequency     order: filter order\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.boldsignal-Tuple{}","page":"API","title":"Neuroblox.boldsignal","text":"Arguments:\n\nname: Name given to ODESystem object within the blox.\nlnϵ  : logarithm of ratio of intra- to extra-vascular signal\n\nNB: the prefix ln of the variables ν, q as well as the parameters ϵ denotes their transformation into logarithmic space to enforce their positivity.\n\nCitations:\n\nStephan K E, Weiskopf N, Drysdale P M, Robinson P A, and Friston K J. Comparing Hemodynamic Models with DCM. NeuroImage 38, no. 3 (2007): 387–401. doi: 10.1016/j.neuroimage.2007.07.040\nHofmann D, Chesebro A G, Rackauckas C, Mujica-Parodi L R, Friston K J, Edelman A, and Strey H H. Leveraging Julia's Automated Differentiation and Symbolic Computation to Increase Spectral DCM Flexibility and Speed, 2023. doi: 10.1101/2023.10.27.564407\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.complexwavelet","page":"API","title":"Neuroblox.complexwavelet","text":"complexwavelet creates a complex morlet wavelet by windowing a complex sine wave with a Gaussian taper.  The morlet wavelet is a special case of a bandpass filter in which the frequency response is Gaussian-shaped. Convolution with a complex wavelet is equivalent to performing a Hilbert transform of a bandpass filtered signal.\n\nIt has the following inputs:     data: time series data      dt  : data sampling rate      lb  : lower bound wavelet frequency (in Hz)     ub  : upper bound wavelet frequency (in Hz)     a   : amplitude of the Gaussian taper, default is 1     n   : number of wavelet cycles of the Gaussian taper, defines the trade-off between temporal precision and frequency precision           larger n gives better frequency precision at the cost of temporal precision           default is 6 Hz     m   : x-axis offset, default is 0     num_wavelets : number of wavelets to create, default is 5\n\nAnd outputs:     complex_wavelet : a family of complex morlet wavelets\n\n\n\n\n\n","category":"function"},{"location":"api/#Neuroblox.csd2mar-NTuple{4, Any}","page":"API","title":"Neuroblox.csd2mar","text":"This function converts a cross-spectral density (CSD) into a multivariate auto-regression (MAR) model. It first transforms the CSD into its cross-correlation function (Wiener-Kinchine theorem) and then computes the MAR model coefficients. csd       : cross-spectral density matrix of size MxN; M: number of samples, N: number of cross-spectral dimensions (number of variables squared) w         : frequencies dt        : time step size p         : number of time steps of auto-regressive model\n\nThis function returns coeff     : array of length p of coefficient matrices of size sqrt(N)xsqrt(N) noise_cov : noise covariance matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.csd_approx-NTuple{4, Any}","page":"API","title":"Neuroblox.csd_approx","text":"This function implements equation 2 of the spectral DCM paper, Friston et al. 2014 \"A DCM for resting state fMRI\".\nNote that nomenclature is taken from SPM12 code and it does not seem to coincide with the spectral DCM paper's nomenclature. \nFor instance, Gu should represent the spectral component due to external input according to the paper. However, in the code this represents\nthe hidden state fluctuations (which are called Gν in the paper).\nGn in the code corresponds to Ge in the paper, i.e. the observation noise. In the code global and local components are defined, no such distinction\nis discussed in the paper. In fact the parameter γ, corresponding to local component is not present in the paper.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.get_dynamic_states-Tuple{Any}","page":"API","title":"Neuroblox.get_dynamic_states","text":"function get_dynamic_states(sys)\n\nFunction extracts states from the system that are dynamic variables, \nget also indices of external inputs (u(t)) and measurements (like bold(t))\nArguments:\n- `sys`: MTK system\n\nReturns:\n- `sts`: states/unknowns of the system that are neither external inputs nor measurements, i.e. these are the dynamic states\n- `idx`: indices of these states\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.get_input_equations-Tuple{Union{Neuroblox.AbstractBlox, Neuroblox.ObserverBlox}}","page":"API","title":"Neuroblox.get_input_equations","text":"Returns the equations for all input variables of a system, \nassuming they have a form like : `sys.input_variable ~ ...`\nso only the input appears on the LHS.\n\nInput equations are namespaced by the inner namespace of blox\nand then they are returned. This way during system `compose` downstream,\nthe higher-level namespaces will be added to them.\n\nIf blox isa AbstractComponent, it is assumed that it contains a `connector` field,\nwhich holds a `BloxConnector` object with all relevant connections \nfrom lower levels and this level.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.idft-Tuple{AbstractArray}","page":"API","title":"Neuroblox.idft","text":"Plain implementation of idft because AD dispatch versions for ifft don't work still!\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.inner_namespaceof-Tuple{Any}","page":"API","title":"Neuroblox.inner_namespaceof","text":"Returns the complete namespace EXCLUDING the outermost (highest) level.\nThis is useful for manually preparing equations (e.g. connections, see BloxConnector),\nthat will later be composed and will automatically get the outermost namespace.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.learningrate-Tuple{Any, Any}","page":"API","title":"Neuroblox.learningrate","text":"This function computes learning rate. It has the following inputs:     outcomes: vector of 1's and 0's for behavioral outcomes     windows: number of windows to split the outcome data into And the following outputs:     rate: the learning rate across each window\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.mar2csd-Tuple{Any, Any, Any}","page":"API","title":"Neuroblox.mar2csd","text":"This function converts multivariate auto-regression (MAR) model parameters to a cross-spectral density (CSD). A     : coefficients of MAR model, array of length p, each element contains the regression coefficients for that particular time-lag. Σ     : noise covariance matrix of MAR p     : number of time lags freqs : frequencies at which to evaluate the CSD sf    : sampling frequency\n\nThis function returns: csd   : cross-spectral density matrix of size MxN; M: number of samples, N: number of cross-spectral dimensions (number of variables squared)\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.mar_ml-Tuple{Any, Any}","page":"API","title":"Neuroblox.mar_ml","text":"Maximum likelihood estimator of a multivariate, or vector auto-regressive model.     y : MxN Data matrix where M is number of samples and N is number of dimensions     p : time lag parameter, also called order of MAR model     return values     mar[\"A\"] : model parameters is a NxNxP tensor, i.e. one NxN parameter matrix for each time bin k ∈ {1,...,p}     mar[\"Σ\"] : noise covariance matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.matlab_norm-Tuple{Any, Any}","page":"API","title":"Neuroblox.matlab_norm","text":"function matlab_norm(A, p)\n\nSimple helper function to implement the norm of a matrix that is equivalent to the one given in MATLAB for order=1, 2, Inf. \nThis is needed for the reproduction of the exact same results of SPM12.\n\nArguments:\n- `A`: matrix\n- `p`: order of norm\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.params-Tuple{Neuroblox.BloxConnector}","page":"API","title":"Neuroblox.params","text":"Helper to merge delays and weights into a single vector\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.paramscoping-Tuple{}","page":"API","title":"Neuroblox.paramscoping","text":"function paramscoping(;kwargs...)\n\nScope arguments that are already a symbolic model parameter thereby keep the correct namespace \nand make those that are not yet symbolic a symbol.\nKeyword arguments are used, because parameter definition require names, not just values.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phase_cos_blox-Union{Tuple{F}, Tuple{Any, Any, F}} where F","page":"API","title":"Neuroblox.phase_cos_blox","text":"phasecosblox is creating a cos with angular frequency ω and variable phase phaseinter has the following parameters:     ω: angular frequency     t: time     phaseinter: a function that returns phase as a function of time and returns:     the resulting value\n\nUsage:     phaseint = phaseinter(0:0.1:50,phasedata)     phaseout(t) = phasecosblox(0.1,t,phaseint)     which is now a function of time and can be used in an input blox     you can also use the dot operator to calculate time-series     signal = phaseout.(collect(0:0.01:50))\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phase_inter-Tuple{Any, Any}","page":"API","title":"Neuroblox.phase_inter","text":"phaseinter is creating a function that interpolates the phase data for any time given phaseinter has the following parameters:     phaserange:  a range, e.g. 0:0.1:50 which should reflect the time points of the data     phasedata: phase at equidistant time points and returns:     an function that returns an interpolated phase for t in range\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phase_sin_blox-Union{Tuple{F}, Tuple{Any, Any, F}} where F","page":"API","title":"Neuroblox.phase_sin_blox","text":"phasesinblox is creating a sin with angular frequency ω and variable phase phaseinter has the following parameters:     ω: angular frequency     t: time     phaseinter: a function that returns phase as a function of time and returns:     the resulting value\n\nUsage:     phaseint = phaseinter(0:0.1:50,phasedata)     phaseout(t) = phasesinblox(0.1,t,phaseint)     which is now a function of time and can be used in an input blox     you can also use the dot operator to calculate time-series     signal = phaseout.(collect(0:0.01:50))\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.phaseangle-Tuple{}","page":"API","title":"Neuroblox.phaseangle","text":"phaseangle takes in time series data, hilbert transforms it, and estimates the phase angle.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.random_initials-Tuple{ODESystem, Any}","page":"API","title":"Neuroblox.random_initials","text":"random_initials creates a vector of random initial conditions for an ODESystem that is composed of a list of blox.  The function finds the initial conditions in the blox and then sets a random value in between range tuple given for that state.\n\nIt has the following inputs:     odesys: ODESystem     blox  : list of blox\n\nAnd outputs:     u0 : Float64 vector of initial conditions\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.sample_affect!-NTuple{4, Any}","page":"API","title":"Neuroblox.sample_affect!","text":"Non-symbolic, time-block-based way of `@register_symbolic sample_poisson(λ)`.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.setup_sDCM-NTuple{9, Any}","page":"API","title":"Neuroblox.setup_sDCM","text":"function setup_sDCM(data, stateevolutionmodel, initcond, csdsetup, priors, hyperpriors, indices)\n\nInterface function to performs variational inference to fit model parameters to empirical cross spectral density.\nThe current implementation provides a Variational Laplace fit (see function above `variationalbayes`).\n\nArguments:\n- `data`        : dataframe with column names corresponding to the regions of measurement.\n- `model`       : MTK model, including state evolution and measurement.\n- `initcond`    : dictionary of initial conditions, numerical values for all states\n- `csdsetup`    : dictionary of parameters required for the computation of the cross spectral density\n-- `dt`         : sampling interval\n-- `freq`       : frequencies at which to evaluate the CSD\n-- `p`          : order parameter of the multivariate autoregression model\n- `priors`      : dataframe of parameters with the following columns:\n-- `name`       : corresponds to MTK model name\n-- `mean`       : corresponds to prior mean value\n-- `variance`   : corresponds to the prior variances\n- `hyperpriors` : dataframe of parameters with the following columns:\n-- `Πλ_pr`      : prior precision matrix for λ hyperparameter(s)\n-- `μλ_pr`      : prior mean(s) for λ hyperparameter(s)\n- `indices`  : indices to separate model parameters from other parameters. Needed for the computation of AD gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.spm_logdet-Tuple{Any}","page":"API","title":"Neuroblox.spm_logdet","text":"function spm_logdet(M)\n\nSPM12 style implementation of the logarithm of the determinant of a matrix.\n\nArguments:\n- `M`: matrix\n\n\n\n\n\n","category":"method"},{"location":"api/#Neuroblox.system_from_graph","page":"API","title":"Neuroblox.system_from_graph","text":"system_from_graph(g::MetaDiGraph, p=Num[]; name, simplify=true, graphdynamics=false, kwargs...)\n\nTake in a MetaDiGraph g describing a network of neural structures (and optionally a vector of extra parameters p) and construct a System which can be used to construct various Problem types (i.e. ODEProblem) for use with DifferentialEquations.jl solvers.\n\nIf simplify is set to true (the default), then the resulting system will have structural_simplify called on it with any remaining keyword arguments forwared to structural_simplify. That is,\n\n@named sys = system_from_graph(g; kwarg1=x, kwarg2=y)\n\nis equivalent to\n\n@named sys = system_from_graph(g; simplify=false)\nsys = structural_simplify(sys; kwarg1=x, kwarg2=y)\n\nSee the docstring for structural_simplify for information on which options it supports.\n\nIf graphdynamics=true (defaults to false), the output will be a GraphSystem from GraphDynamics.jl, and the kwargs will be sent to the GraphDynamics constructor instead of using ModelingToolkit.jl. The GraphDynamics.jl backend is typically significantly faster for large neural systems than the default backend, but is experimental and does not yet support all Neuroblox.jl features. \n\n\n\n\n\n","category":"function"},{"location":"api/#Neuroblox.vecparam-Tuple{OrderedCollections.OrderedDict}","page":"API","title":"Neuroblox.vecparam","text":"vecparam(param::OrderedDict)\n\nFunction to flatten an ordered dictionary of model parameters and return a simple list of parameter values.\n\nArguments:\n- `param`: dictionary of model parameters (may contain numbers and lists of numbers)\n\n\n\n\n\n","category":"method"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"EditURL = \"basal_ganglia.jl\"","category":"page"},{"location":"tutorials/basal_ganglia/#Basal-Ganglia-Model-and-Parkinson's-Disease-Simulation","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"","category":"section"},{"location":"tutorials/basal_ganglia/#Introduction","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Introduction","text":"","category":"section"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"This tutorial demonstrates how to build and simulate a basal ganglia model using Neuroblox, based on the work of Adam et al. (2022). We'll explore the model's behavior in both normal and Parkinsonian conditions, showcasing the emergence of pathological beta oscillations characteristic of Parkinson's disease.","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"(Image: Full basal ganglia model in baseline condition)","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"We'll start with simple components and gradually build up to the full basal ganglia circuit, demonstrating how to analyze the results at each stage.","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"using Neuroblox\nusing StochasticDiffEq ## For building and solving differential equations problems\nusing CairoMakie ## For plotting\nusing Random ## For setting a random seed\n\nRandom.seed!(123) ## Set a random seed for reproducibility","category":"page"},{"location":"tutorials/basal_ganglia/#Isolated-MSN-network-in-baseline-condition","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Isolated MSN network in baseline condition","text":"","category":"section"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"We'll start by simulating an isolated network of Medium Spiny Neurons (MSNs)","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Blox definition","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"N_MSN = 100 ## number of Medium Spiny Neurons\n@named msn = Striatum_MSN_Adam(N_inhib = N_MSN)\nsys = get_system(msn; simplify = true)\n\n# Check the system's variables (100 neurons, each with associated currents)\nunknowns(sys)","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Create and solve the SDE problem","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"# Define simulation parameters\ntspan = (0.0, 2000.0) ## simulation time span [ms]\ndt = 0.05 ## time step for solving and saving [ms]\n\n# Create a stochastic differential equation problem and use the RKMil method to solve it\nprob = SDEProblem(sys, [], tspan, [])\nsol = solve(prob, RKMil(); dt=dt, saveat=dt, abstol = 1e-2, reltol = 1e-2);\nnothing #hide","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Plot voltage of a single neuron","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"plot(sol, idxs=1, axis = (xlabel = \"time (ms)\", ylabel = \"membrane potential (mV)\"))","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Plot mean field","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"meanfield(msn, sol, axis = (xlabel = \"time (ms)\", ylabel = \"membrane potential (mV)\", title = \"Mean Field\"))","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Detect spikes and compute firing rate","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"spikes = detect_spikes(msn, sol; threshold=-55)\nt, fr = mean_firing_rate(spikes, sol)","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Create a raster plot","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"rasterplot(msn, sol, threshold = -55.0, title = \"Neuron's Spikes - Mean Firing Rate: $(round(fr[1], digits=2)) spikes/s\")","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Compute and plot the power spectrum of the GABAa current","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"fig = Figure(size = (1500, 600))\n\npowerspectrumplot(fig[1,1], msn, sol; state = \"G\",\n                  ylims=(1e-5, 10),\n                  alpha_start = 5,\n                  alpha_label_position = (8.5, 5),\n                  beta_label_position = (22, 5),\n                  gamma_label_position = (60, 5),\n                  title = \"FFT with no window\")\n\npowerspectrumplot(fig[1,2], msn, sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_start = 5,\n                  alpha_label_position = (8.5, 5),\n                  beta_label_position = (22, 5),\n                  gamma_label_position = (60, 5),\n                  title = \"Welch's method + Hanning window\")\nfig","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"We can also run multiple simulations in parallel and compute the average power spectrum","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"ens_prob = EnsembleProblem(prob)\nens_sol = solve(ens_prob, RKMil(); dt=dt, saveat=dt, trajectories=3, abstol = 1e-2, reltol = 1e-2);\n\npowerspectrumplot(msn, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_start = 8,\n                  alpha_label_position = (8.5, 4),\n                  beta_label_position = (22, 4),\n                  gamma_label_position = (60, 4),\n                  title = \"Welch's method + Hanning window + Ensemble\")","category":"page"},{"location":"tutorials/basal_ganglia/#Core-striatal-network:-MSN-FSI","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Core striatal network: MSN + FSI","text":"","category":"section"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Now we'll add Fast-Spiking Interneurons (FSIs) to our model","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"global_ns = :g ## global name for the circuit. All components should be inside this namespace.\n\nN_FSI = 50 ## number of Fast Spiking Interneurons\n@named msn = Striatum_MSN_Adam(namespace=global_ns, N_inhib = N_MSN)\n@named fsi = Striatum_FSI_Adam(namespace=global_ns, N_inhib = N_FSI)\n\nḡ_FSI_MSN = 0.6 ## maximal conductance for FSI to MSN synapses [mS/cm^-2]\ndensity_FSI_MSN = 0.15 ## fraction of FSIs connecting to the MSN population\nweight_FSI_MSN = ḡ_FSI_MSN / (N_FSI * density_FSI_MSN) ## normalized synaptic weight\n\ng = MetaDiGraph()\nadd_edge!(g, fsi => msn; weight = weight_FSI_MSN, density = density_FSI_MSN)\n\n@named sys = system_from_graph(g)\nprob = SDEProblem(sys, [], tspan, [])\nens_prob = EnsembleProblem(prob)\nens_sol = solve(ens_prob, RKMil(); dt=dt, saveat=dt, trajectories=3, abstol = 1e-2, reltol = 1e-2);\nnothing #hide","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Detect spikes and compute firing rates","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"spikes_msn = detect_spikes(msn, ens_sol[1]; threshold=-35)\nt, fr_msn = mean_firing_rate(spikes_msn, ens_sol[1])\n\nspikes_fsi = detect_spikes(fsi, ens_sol[1]; threshold=-25)\nt, fr_fsi = mean_firing_rate(spikes_fsi, ens_sol[1])","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Let's see their raster plots and power spectra","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"fig = Figure(size = (1000, 800))\nrasterplot(fig[1,1], msn, ens_sol[1], threshold = -35.0, title = \"MSN - Mean Firing Rate: $(round(fr_msn[1], digits=2)) spikes/s\")\nrasterplot(fig[1,2], fsi, ens_sol[1], threshold = -35.0, title = \"FSI - Mean Firing Rate: $(round(fr_fsi[1], digits=2)) spikes/s\")\n\npowerspectrumplot(fig[2,1], msn, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  xlims=(8, 100),\n                  alpha_label_position = (8.5, 3),\n                  beta_label_position = (22, 3),\n                  gamma_label_position = (60, 3))\n\npowerspectrumplot(fig[2,2], fsi, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  xlims=(8, 100),\n                  alpha_label_position = (8.5, 3),\n                  beta_label_position = (22, 3),\n                  gamma_label_position = (60, 3))\nfig","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"FSIs exhibit a peak in gamma frequencies. Their inhibition onto MSNs suppresses the low beta-band activity seen in isolated MSN populations, without reducing MSN firing rates. This spectral shift reflects a change in MSN spiking dynamics under FSI influence, rather than a decrease in overall activity.","category":"page"},{"location":"tutorials/basal_ganglia/#Full-basal-ganglia-model-in-baseline-condition","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Full basal ganglia model in baseline condition","text":"","category":"section"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Now we'll add the GPe and STN to complete the full basal ganglia model","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"N_GPe = 80 ## number of GPe neurons\nN_STN = 40 ## number of STN neurons\n\n@named gpe = GPe_Adam(namespace=global_ns, N_inhib = N_GPe)\n@named stn = STN_Adam(namespace=global_ns, N_exci = N_STN)\n\nḡ_MSN_GPe = 2.5 ## maximal conductance for MSN to GPe synapses [mS/cm^-2]\nḡ_GPe_STN = 0.3 ## maximal conductance for GPe to STN synapses [mS/cm^-2]\nḡ_STN_FSI = 0.165 ## maximal conductance for STN to FSI synapses [mS/cm^-2]\n\ndensity_MSN_GPe = 0.33 ## fraction of MSNs connecting to the GPe population\ndensity_GPe_STN = 0.05 ## fraction of GPe neurons connecting to the STN population\ndensity_STN_FSI = 0.1 ## fraction of STN neurons connecting to the FSI population\n\nweight_MSN_GPe = ḡ_MSN_GPe / (N_MSN * density_MSN_GPe)\nweight_GPe_STN = ḡ_GPe_STN / (N_GPe * density_GPe_STN)\nweight_STN_FSI = ḡ_STN_FSI / (N_STN * density_STN_FSI)\n\ng = MetaDiGraph()\nadd_edge!(g, fsi => msn, weight = weight_FSI_MSN, density = density_FSI_MSN)\nadd_edge!(g, msn => gpe, weight = weight_MSN_GPe, density = density_MSN_GPe)\nadd_edge!(g, gpe => stn, weight = weight_GPe_STN, density = density_GPe_STN)\nadd_edge!(g, stn => fsi, weight = weight_STN_FSI, density = density_STN_FSI)\n\n@named sys = system_from_graph(g)\nprob = SDEProblem(sys, [], tspan, [])\nens_prob = EnsembleProblem(prob)\nens_sol = solve(ens_prob, RKMil(); dt=dt, saveat=dt, trajectories=3, abstol = 1e-2, reltol = 1e-2);\nnothing #hide","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Compute and plot power spectra for all components","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"fig = Figure(size = (1500, 600))\n\npowerspectrumplot(fig[1,1], msn, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"MSN (Baseline)\")\n\npowerspectrumplot(fig[1,2], fsi, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"FSI (Baseline)\")\n\npowerspectrumplot(fig[1,3], gpe, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"GPe (Baseline)\")\n\npowerspectrumplot(fig[1,4], stn, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"STN (Baseline)\")\n\nfig","category":"page"},{"location":"tutorials/basal_ganglia/#Full-basal-ganglia-model-in-Parkinson's-condition","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Full basal ganglia model in Parkinson's condition","text":"","category":"section"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Finally, we'll adjust the model parameters to simulate Parkinson's disease conditions","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"(Image: Full basal ganglia model in Parkinsonian conditions)","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"The key changes from baseline to Parkinsonian conditions are:","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"For MSNs:\nIncreased background excitation (I_bg) to 1.2519 μA·cm^-2\nDecreased maximal conductance for M-current (G_M) to 1.2 mS·cm^-2\nFor FSIs:\nDecreased background excitation (I_bg) to 4.511 μA·cm^-2\nDecreased maximal conductance of FSI-MSN projection (ḡ_FSI_MSN) by 20% to 0.48 mS·cm^-2, due to increased cholinergic tone\nDecreased maximal conductance of FSI-FSI projection (weight) to 0.2 mS·cm^-2\nDecreased electrical conductance (g_elec) to 0.075","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"These changes reflect the loss of dopamine and increase in cholinergic tone characteristic of Parkinson's disease.","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Create bloxs with Parkinsonian parameters","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"@named msn = Striatum_MSN_Adam(namespace=global_ns, N_inhib = N_MSN, I_bg = 1.2519*ones(N_MSN), G_M = 1.2)\n@named fsi = Striatum_FSI_Adam(namespace=global_ns, N_inhib = N_FSI, I_bg = 4.511*ones(N_FSI), weight = 0.2, g_weight = 0.075)\n\nḡ_FSI_MSN = 0.48 ## decreased maximal conductance of FSI-MSN projection [mS/cm^-2]\nweight_FSI_MSN = ḡ_FSI_MSN / (N_FSI * density_FSI_MSN) ## normalized synaptic weight\n\ng = MetaDiGraph()\nadd_edge!(g, fsi => msn, weight = weight_FSI_MSN, density = density_FSI_MSN)\nadd_edge!(g, msn => gpe, weight = weight_MSN_GPe, density = density_MSN_GPe)\nadd_edge!(g, gpe => stn, weight = weight_GPe_STN, density = density_GPe_STN)\nadd_edge!(g, stn => fsi, weight = weight_STN_FSI, density = density_STN_FSI)\n\n@named sys = system_from_graph(g)\n\nprob = SDEProblem(sys, [], tspan, [])\nens_prob = EnsembleProblem(prob)\nens_sol = solve(ens_prob, RKMil(); dt=dt, saveat=dt, trajectories=3, abstol = 1e-2, reltol = 1e-2);\nnothing #hide","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Compute and compare power spectra for all neural populations in Parkinsonian condition against their counterparts in baseline conditions.","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"powerspectrumplot(fig[2,1], msn, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"MSN (PD)\")\n\npowerspectrumplot(fig[2,2], fsi, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"FSI (PD)\")\n\npowerspectrumplot(fig[2,3], gpe, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_start = 5,\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"GPe (PD)\")\n\npowerspectrumplot(fig[2,4], stn, ens_sol; state = \"G\",\n                  method=welch_pgram, window=hanning,\n                  ylims=(1e-5, 10),\n                  alpha_label_position = (8.5, 2),\n                  beta_label_position = (22, 2),\n                  gamma_label_position = (60, 2),\n                  title = \"STN (PD)\")\n\nfig","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"We see the emergence of strong beta oscillations in the Parkinsonian condition compared to the baseline condition for all neural populations. This aligns with the findings of Adam et al. and reflects the pathological synchrony observed in Parkinson's disease.","category":"page"},{"location":"tutorials/basal_ganglia/#References","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"References","text":"","category":"section"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"Adam, Elie M., et al. \"Deep brain stimulation in the subthalamic nucleus for Parkinson's disease can restore dynamics of striatal networks.\" Proceedings of the National Academy of Sciences 119.19 (2022): e2120808119.","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"","category":"page"},{"location":"tutorials/basal_ganglia/","page":"Basal Ganglia Model and Parkinson's Disease Simulation","title":"Basal Ganglia Model and Parkinson's Disease Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"EditURL = \"getting_started.jl\"","category":"page"},{"location":"getting_started/#Getting-Started-with-Neuroblox","page":"Getting Started","title":"Getting Started with Neuroblox","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This tutorial will introduce you to simulating brain dynamics using Neuroblox. In this example, we'll create a simple oscillating circuit using two Wilson-Cowan neural mass models [1]. The Wilson-Cowan model is one of the most influential models in computational neuroscience [2], describing the dynamics of interactions between populations of excitatory and inhibitory neurons.","category":"page"},{"location":"getting_started/#The-Wilson-Cowan-Model","page":"Getting Started","title":"The Wilson-Cowan Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Each Wilson-Cowan neural mass is described by the following equations:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"beginalign\nnonumber\nfracdEdt = frac-Etau_E + S_E(c_EEE - c_IEI + etatextstylesumjcn)10pt\nnonumber\nfracdIdt = frac-Itau_I + S_Ileft(c_EIE - c_IIIright)\nendalign","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"where E and I denote the activity levels of the excitatory and inhibitory populations, respectively. The terms fracdEdt and fracdIdt describe the rate of change of these activity levels over time. The parameters tau_E and tau_I are time constants analogous to membrane time constants in single neuron models, determining how quickly the excitatory and inhibitory populations respond to changes. The coefficients c_EE and c_II represent self-interaction (or feedback) within excitatory and inhibitory populations, while c_IE and c_EI represent the cross-interactions between the two populations. The term etasumjcn represents external input to the excitatory population from other brain regions or external stimuli, with eta acting as a scaling factor. While S_E and S_I are sigmoid functions that represent the responses of neuronal populations to input stimuli, defined as:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"S_k(x) = frac11 + exp(-a_kx - theta_k)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"where a_k and theta_k determine the steepness and threshold of the response, respectively.","category":"page"},{"location":"getting_started/#Building-the-Circuit","page":"Getting Started","title":"Building the Circuit","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Let's create an oscillating circuit by connecting two Wilson-Cowan neural masses:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Neuroblox\nusing OrdinaryDiffEq\nusing CairoMakie\n\n# Create two Wilson-Cowan blox\n@named WC1 = WilsonCowan()\n@named WC2 = WilsonCowan()\n\n# Create a graph to represent our circuit\ng = MetaDiGraph()\nadd_blox!.(Ref(g), [WC1, WC2])\n\n# Define the connectivity between the neural masses\nadd_edge!(g, WC1 => WC1; weight = -1) ## recurrent connection from WC1 to itself\nadd_edge!(g, WC1 => WC2; weight = 7) ## connection from WC1 to WC2\nadd_edge!(g, WC2 => WC1; weight = 4) ## connection from WC2 to WC1\nadd_edge!(g, WC2 => WC2; weight = -1) ## recurrent connection from WC2 to itself","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here, we've created two Wilson-Cowan Blox and connected them as nodes in a directed graph. The adj matrix defines the weighted edges between these nodes. Each entry adj[i,j] represents how the output of blox j influences the input of blox i:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Diagonal elements (adj[1,1] and adj[2,2]): Self-connections, adding feedback to each blox.\nOff-diagonal elements (adj[1,2] and adj[2,1]): Inter-blox connections, determining how each blox influences the other.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"By default, the output of each Wilson-Cowan blox is its excitatory activity (E). The negative self-connections (-1) provide inhibitory feedback, while the positive inter-blox connections (6) provide strong excitatory coupling. This setup creates an oscillatory dynamic between the two Wilson-Cowan units.","category":"page"},{"location":"getting_started/#Creating-the-Model","page":"Getting Started","title":"Creating the Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Now, let's build the complete model:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"@named sys = system_from_graph(g)","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This creates a differential equations system from our graph representation using ModelingToolkit and symbolically simplifies it for efficient computation.","category":"page"},{"location":"getting_started/#Simulating-the-Model","page":"Getting Started","title":"Simulating the Model","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"We are now ready to simulate our model. The following code creates and solves an ODEProblem for our system, simulating 100 time units of activity. In Neuroblox, the default time unit is milliseconds. We use Rodas4, a solver efficient for stiff problems. The solution is saved every 0.1 ms, allowing us to observe the detailed evolution of the system's behavior.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"prob = ODEProblem(sys, [], (0.0, 100), [])\nsol = solve(prob, Rodas4(), saveat=0.1)","category":"page"},{"location":"getting_started/#Plotting-simulation-results","page":"Getting Started","title":"Plotting simulation results","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Finally, let us plot the E and I states of the first component, WC1.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"E1 = state_timeseries(WC1, sol, \"E\")\nI1 = state_timeseries(WC1, sol, \"I\")\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time (ms)\")\nlines!(ax, sol.t, E1, label = \"E\")\nlines!(ax, sol.t, I1, label = \"I\")\nLegend(fig[1,2], ax)\nfig","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[1] Wilson, H. R., & Cowan, J. D. (1972). Excitatory and inhibitory interactions in localized populations of model neurons. Biophysical journal, 12(1), 1-24.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"[2] Destexhe, A., & Sejnowski, T. J. (2009). The Wilson–Cowan model, 36 years later. Biological cybernetics, 101(1), 1-2.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"EditURL = \"parkinsons.jl\"","category":"page"},{"location":"tutorials/parkinsons/#Building-a-model-of-Parkinson's-disease-using-Neural-Mass-models","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"In this example, we'll construct a model of Parkinson's disease using eight Jansen-Rit Neural Mass Models, based on the work of Liu et al. (2020) [1].","category":"page"},{"location":"tutorials/parkinsons/#The-Jansen-Rit-Neural-Mass-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"The Jansen-Rit Neural Mass Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"The Jansen-Rit model [2] is another popular neural mass model that, like the Wilson-Cowan model from Example 1, describes the average activity of neural populations. Each Jansen-Rit unit is defined by the following differential equations:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"beginalign\nfracdxdt = y-frac2taux 10pt\nfracdydt = -fracxtau^2 + fracHtau left2lambda S(textstylesumjcn) - lambdaright\nendalign","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"where x represents the average postsynaptic membrane potential of the neural population, y is an auxiliary variable, tau is the membrane time constant, H is the maximum postsynaptic potential amplitude, lambda determines the maximum firing rate, and sumjcn represents the sum of all synaptic inputs to the population. The sigmoid function S(x) models the population's firing rate response to input and is defined as:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"S(x) = frac11 + textexp(-rx)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"where r controls the steepness of the sigmoid, affecting the population's sensitivity to input.","category":"page"},{"location":"tutorials/parkinsons/#Setting-Up-the-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Setting Up the Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Let's start by importing the necessary libraries and defining our neural masses:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"using Neuroblox\nusing OrdinaryDiffEq\nusing CairoMakie\n\n# Convert time units from seconds to milliseconds\nτ_factor = 1000\n\n# Define Jansen-Rit neural masses for different brain regions\n@named Str = JansenRit(τ=0.0022*τ_factor, H=20/τ_factor, λ=300, r=0.3)\n@named GPE = JansenRit(τ=0.04*τ_factor, cortical=false)  # all default subcortical except τ\n@named STN = JansenRit(τ=0.01*τ_factor, H=20/τ_factor, λ=500, r=0.1)\n@named GPI = JansenRit(cortical=false)  # default parameters subcortical Jansen Rit blox\n@named Th  = JansenRit(τ=0.002*τ_factor, H=10/τ_factor, λ=20, r=5)\n@named EI  = JansenRit(τ=0.01*τ_factor, H=20/τ_factor, λ=5, r=5)\n@named PY  = JansenRit(cortical=true)  # default parameters cortical Jansen Rit blox\n@named II  = JansenRit(τ=2.0*τ_factor, H=60/τ_factor, λ=5, r=5)\n\nblox = [Str, GPE, STN, GPI, Th, EI, PY, II]\n\n\n#Here, we've created eight Jansen-Rit neural masses representing different brain regions involved in Parkinson's disease. The `τ_factor` is used to convert time units from seconds (as in the original paper) to milliseconds (Neuroblox's default time unit).","category":"page"},{"location":"tutorials/parkinsons/#Building-the-Circuit","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building the Circuit","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Now, let's create a graph representing our brain circuit:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"g = MetaDiGraph()\nadd_blox!.(Ref(g), blox)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"We've created a MetaDiGraph and added our neural masses as nodes. Next, we'll define the connections between these nodes based on the known anatomy of the basal ganglia-thalamocortical circuit.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"ModelingToolkit allows us to create parameters that can be passed into the equations symbolically:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"As an alternative to creating edges with an adjacency matrix (as shown in the previous example), here we demonstrate a different approach by adding edges one by one. In this case, we set the connections specified in Table 2 of Liu et al. [1], although we only implement a subset of the nodes and edges to describe a simplified version of the model:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"# Define connection strength parameters\nparams = @parameters C_Cor=60 C_BG_Th=60 C_Cor_BG_Th=5 C_BG_Th_Cor=5\n\nadd_edge!(g, 2, 1, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 2, 2, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 2, 3, Dict(:weight => C_BG_Th))\nadd_edge!(g, 3, 2, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 3, 7, Dict(:weight => C_Cor_BG_Th))\nadd_edge!(g, 4, 2, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 4, 3, Dict(:weight => C_BG_Th))\nadd_edge!(g, 5, 4, Dict(:weight => -0.5*C_BG_Th))\nadd_edge!(g, 6, 5, Dict(:weight => C_BG_Th_Cor))\nadd_edge!(g, 6, 7, Dict(:weight => 6*C_Cor))\nadd_edge!(g, 7, 6, Dict(:weight => 4.8*C_Cor))\nadd_edge!(g, 7, 8, Dict(:weight => -1.5*C_Cor))\nadd_edge!(g, 8, 7, Dict(:weight => 1.5*C_Cor))\nadd_edge!(g, 8, 8, Dict(:weight => 3.3*C_Cor))\nadd_edge!(g,1,1,:weight, -0.5*C_BG_Th)\nadd_edge!(g,1,2,:weight, C_BG_Th)\nadd_edge!(g,2,1,:weight, -0.5*C_BG_Th)\nadd_edge!(g,2,5,:weight, C_Cor_BG_Th)\nadd_edge!(g,3,1,:weight, -0.5*C_BG_Th)\nadd_edge!(g,3,2,:weight, C_BG_Th)\nadd_edge!(g,4,3,:weight, -0.5*C_BG_Th)\nadd_edge!(g,4,4,:weight, C_BG_Th_Cor)","category":"page"},{"location":"tutorials/parkinsons/#Creating-the-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Creating the Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Let's build the complete model:","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"@named final_system = system_from_graph(g)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"This creates a differential equations system from our graph representation using ModelingToolkit and symbolically simplifies it for efficient computation.","category":"page"},{"location":"tutorials/parkinsons/#Simulating-the-Model","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Simulating the Model","text":"","category":"section"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"Lastly, we create the ODEProblem for our system, select an algorithm, in this case Tsit5(), and simulate 1 second of brain activity.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"sim_dur = 1000.0 # Simulate for 1 second\nprob = ODEProblem(final_system, [], (0.0, sim_dur))\nsol = solve(prob, Tsit5(), saveat=1)","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"[1] Liu, C., Zhou, C., Wang, J., Fietkiewicz, C., & Loparo, K. A. (2020). The role of coupling connections in a model of the cortico-basal ganglia-thalamocortical neural loop for the generation of beta oscillations. Neural Networks, 123, 381-392.","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"","category":"page"},{"location":"tutorials/parkinsons/","page":"Building a model of Parkinson's disease using Neural Mass models","title":"Building a model of Parkinson's disease using Neural Mass models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"EditURL = \"spectralDCM.jl\"","category":"page"},{"location":"tutorials/spectralDCM/#Spectral-Dynamic-Causal-Modeling-Tutorial","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"","category":"section"},{"location":"tutorials/spectralDCM/#Introduction","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Introduction","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"In this tutorial we will introduce how to perform a spectral Dynamic Causal Modeling analysis on simulated data [1,2]. To do so we roughly resemble the procedure in the SPM12 script DEM_demo_induced_fMRI.m in Neuroblox. This work was also presented in Hofmann et al.[2]","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"In this tutorial we will define a circuit of three linear neuronal mass models, all driven by an Ornstein-Uhlenbeck process. We will model fMRI data by a balloon model and BOLD signal on top. After simulation of this simple model we will use spectral Dynamic Causal Modeling to infer some of the model parameters from the simulation time series.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"(Image: Workflow illustration)","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"A brief outline of the procedure we will pursue:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"define the graph, add blocks -> section A, B and C in the figure\nsimulate the model -> instead we could also use actual data, section D in figure\ncompute the cross spectral density\nsetup the DCM\nestimate parameters\nplot the results","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"using Neuroblox\nusing LinearAlgebra\nusing StochasticDiffEq\nusing DataFrames\nusing OrderedCollections\nusing CairoMakie\nusing ModelingToolkit","category":"page"},{"location":"tutorials/spectralDCM/#Model-simulation","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Model simulation","text":"","category":"section"},{"location":"tutorials/spectralDCM/#Define-the-model","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Define the model","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"We will define a model of 3 regions. This means first of all to define a graph. To this graph we will add three linear neuronal mass models which constitute the (hidden) neuronal dynamics. These constitute three nodes of the graph. Next we will also need some input that stimulates the activity, we use simple Ornstein-Uhlenbeck blocks to create stochastic inputs. One per region. We want to simulate fMRI signals thus we will need to also add a BalloonModel per region. Note that the Ornstein-Uhlenbeck block will feed into the linear neural mass which in turn will feed into the BalloonModel blox. This needs to be represented by the way we define the edges.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"nr = 3             # number of regions\ng = MetaDiGraph()\nregions = [];   # list of neural mass blocks to then connect them to each other with an adjacency matrix `A_true`\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Now add the different blocks to each region and connect the blocks within each region:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"for i = 1:nr\n    region = LinearNeuralMass(;name=Symbol(\"r$(i)₊lm\"))\n    push!(regions, region)          # store neural mass model for connection of regions\n\n    # add Ornstein-Uhlenbeck block as noisy input to the current region\n    input = OUBlox(;name=Symbol(\"r$(i)₊ou\"), σ=0.1)\n    add_edge!(g, input => region; :weight => 1/16)   # Note that 1/16 is taken from SPM12, this stabilizes the balloon model simulation. Alternatively the noise of the Ornstein-Uhlenbeck block or the weight of the edge connecting neuronal activity and balloon model could be reduced to guarantee numerical stability.\n\n    # simulate fMRI signal with BalloonModel which includes the BOLD signal on top of the balloon model dynamics\n    measurement = BalloonModel(;name=Symbol(\"r$(i)₊bm\"))\n    add_edge!(g, region => measurement; :weight => 1.0)\nend","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Next we define the between-region connectivity matrix and make sure that it is diagonally dominant to guarantee numerical stability (see Gershgorin theorem).","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"A_true = 0.1*randn(nr, nr)\nA_true -= diagm(map(a -> sum(abs, a), eachrow(A_true)))    # ensure diagonal dominance of matrix\nfor idx in CartesianIndices(A_true)\n    add_edge!(g, regions[idx[1]] => regions[idx[2]]; :weight => A_true[idx[1], idx[2]])\nend","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"finally we compose the simulation model","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"@named simmodel = system_from_graph(g, split=false)","category":"page"},{"location":"tutorials/spectralDCM/#Run-the-simulation-and-plot-the-results","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Run the simulation and plot the results","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"setup simulation of the model, time in seconds","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"tspan = (0.0, 612.0)\nprob = SDEProblem(simmodel, [], tspan)\ndt = 2.0   # two seconds as measurement interval for fMRI\nsol = solve(prob, ImplicitRKMil(), saveat=dt);\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"plot bold signal time series","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"idx_m = get_idx_tagged_vars(simmodel, \"measurement\")    # get index of bold signal\nf = Figure()\nax = Axis(f[1, 1],\n    title = \"fMRI time series\",\n    xlabel = \"Time [s]\",\n    ylabel = \"BOLD\",\n)\nlines!(ax, sol, idxs=idx_m)\nf","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"We note that the initial spike is not meaningful and a result of the equilibration of the stochastic process thus we remove it.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"dfsol = DataFrame(sol[ceil(Int, 101/dt):end]);\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/#Estimate-and-plot-the-cross-spectral-densities","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Estimate and plot the cross-spectral densities","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"nameswitht = [n * \"(t)\" for n in names(dfsol)]  # this will hopefully soon become obsolete once https://github.com/SciML/SciMLBase.jl/issues/798 is fixed\nrename!(dfsol, nameswitht)\ndata = Matrix(dfsol[:, idx_m]);\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"We compute the cross-spectral density by fitting a linear model of order p and then compute the csd analytically from the parameters of the multivariate autoregressive model","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"p = 8\nmar = mar_ml(data, p)   # maximum likelihood estimation of the MAR coefficients and noise covariance matrix\nns = size(data, 1)\nfreq = range(min(128, ns*dt)^-1, max(8, 2*dt)^-1, 32)\ncsd = mar2csd(mar, freq, dt^-1);\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Now plot the cross-spectrum:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"fig = Figure(size=(1200, 800))\ngrid = fig[1, 1] = GridLayout()\nfor i = 1:nr\n    for j = 1:nr\n        ax = Axis(grid[i, j])\n        lines!(ax, freq, real.(csd[:, i, j]))\n    end\nend\nfig","category":"page"},{"location":"tutorials/spectralDCM/#Model-Inference","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Model Inference","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"We will now assemble a new model that is used for fitting the previous simulations. This procedure is similar to before with the difference that we will define global parameters and use tags such as [tunable=false/true] to define which parameters we will want to estimate. Note that parameters are tunable by default.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"g = MetaDiGraph()\nregions = [];   # list of neural mass blocks to then connect them to each other with an adjacency matrix `A`\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"The following parameters are shared accross regions, which is why we define them here.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"@parameters lnκ=0.0 [tunable=false] lnϵ=0.0 [tunable=false] lnτ=0.0 [tunable=false]   # lnκ: decay parameter for hemodynamics; lnϵ: ratio of intra- to extra-vascular components, lnτ: transit time scale\n@parameters C=1/16 [tunable=false]   # note that C=1/16 is taken from SPM12 and stabilizes the balloon model simulation. See also comment above.\n\nfor i = 1:nr\n    region = LinearNeuralMass(;name=Symbol(\"r$(i)₊lm\"))\n    push!(regions, region)\n    input = ExternalInput(;name=Symbol(\"r$(i)₊ei\"))\n    add_edge!(g, input => region; :weight => C)\n\n    # we assume fMRI signal and model them with a BalloonModel\n    measurement = BalloonModel(;name=Symbol(\"r$(i)₊bm\"), lnτ=lnτ, lnκ=lnκ, lnϵ=lnϵ)\n    add_edge!(g, region => measurement; :weight => 1.0)\nend\n\nA_prior = 0.01*randn(nr, nr)\nA_prior -= diagm(diag(A_prior))    # ensure diagonal dominance of matrix","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Since we want to optimize these weights we turn them into symbolic parameters: Add the symbolic weights to the edges and connect reegions.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"@parameters A[1:nr^2] = vec(A_prior) [tunable = true]\nfor (i, idx) in enumerate(CartesianIndices(A_prior))\n    if idx[1] == idx[2]\n        add_edge!(g, regions[idx[1]] => regions[idx[2]]; :weight => -exp(A[i])/2)  # -exp(A[i])/2: treatement of diagonal elements in SPM12 to make diagonal dominance (see Gershgorin Theorem) more likely but it is not guaranteed\n    else\n        add_edge!(g, regions[idx[2]] => regions[idx[1]]; :weight => A[i])\n    end\nend\n\n@named fitmodel = system_from_graph(g, split=false)","category":"page"},{"location":"tutorials/spectralDCM/#Setup-spectral-DCM","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Setup spectral DCM","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"max_iter = 128;            # maximum number of iterations\n# attribute initial conditions to states\nsts, _ = get_dynamic_states(fitmodel);\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"the following step is needed if the model's Jacobian would give degenerate eigenvalues if expanded around 0 (which is the default expansion)","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"perturbedfp = Dict(sts .=> abs.(0.001*rand(length(sts))))     # slight noise to avoid issues with Automatic Differentiation. TODO: find different solution, this is hacky.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"We can use the default prior function to use standardized prior values as given in SPM12.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"pmean, pcovariance, indices = defaultprior(fitmodel, nr)\n\npriors = (μθ_pr = pmean,\n          Σθ_pr = pcovariance\n         );\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Setup hyper parameter prior as well:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"hyperpriors = Dict(:Πλ_pr => 128.0*ones(1, 1),   # prior metaparameter precision, needs to be a matrix\n                   :μλ_pr => [8.0]               # prior metaparameter mean, needs to be a vector\n                  );\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"To compute the cross spectral densities we need to provide the sampling interval of the time series, the frequency axis and the order of the multivariate autoregressive model:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"csdsetup = (mar_order = p, freq = freq, dt = dt);\n\n_, s_bold = get_eqidx_tagged_vars(fitmodel, \"measurement\");    # get bold signal variables\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Prepare the DCM:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"(state, setup) = setup_sDCM(dfsol[:, String.(Symbol.(s_bold))], fitmodel, perturbedfp, csdsetup, priors, hyperpriors, indices, pmean, \"fMRI\");\n\n# HACK: on machines with very small amounts of RAM, Julia can run out of stack space while compiling the code called in this loop\n# this should be rewritten to abuse the compiler less, but for now, an easy solution is just to run it with more allocated stack space.\nwith_stack(f, n) = fetch(schedule(Task(f, n)));\nnothing #hide","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"We are ready to run the optimization procedure! :)","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"with_stack(5_000_000) do  # 5MB of stack space\n    for iter in 1:max_iter\n        state.iter = iter\n        run_sDCM_iteration!(state, setup)\n        print(\"iteration: \", iter, \" - F:\", state.F[end] - state.F[2], \" - dF predicted:\", state.dF[end], \"\\n\")\n        if iter >= 4\n            criterion = state.dF[end-3:end] .< setup.tolerance\n            if all(criterion)\n                print(\"convergence\\n\")\n                break\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/spectralDCM/#Plot-Results","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Plot Results","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"(Later place all into one figure using Makie-style layouts) Plot the free energy evolution over optimization iterations:","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"freeenergy(state)","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"Plot the estimated posterior of the effective connectivity and compare that to the true parameter values. Bar hight are the posterior mean and error bars are the standard deviation of the posterior.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"ecbarplot(state, setup, A_true)","category":"page"},{"location":"tutorials/spectralDCM/#References","page":"Spectral Dynamic Causal Modeling Tutorial","title":"References","text":"","category":"section"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"[1] Novelli, Leonardo, Karl Friston, and Adeel Razi. “Spectral Dynamic Causal Modeling: A Didactic Introduction and Its Relationship with Functional Connectivity.” Network Neuroscience 8, no. 1 (April 1, 2024): 178–202. \n[2] Hofmann, David, Anthony G. Chesebro, Chris Rackauckas, Lilianne R. Mujica-Parodi, Karl J. Friston, Alan Edelman, and Helmut H. Strey. “Leveraging Julia’s Automated Differentiation and Symbolic Computation to Increase Spectral DCM Flexibility and Speed.” bioRxiv: The Preprint Server for Biology, 2023.","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"","category":"page"},{"location":"tutorials/spectralDCM/","page":"Spectral Dynamic Causal Modeling Tutorial","title":"Spectral Dynamic Causal Modeling Tutorial","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"EditURL = \"neural_assembly.jl\"","category":"page"},{"location":"tutorials/neural_assembly/#Tutorial-on-bottom-up-approach-to-building-a-neural-assembly","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"","category":"section"},{"location":"tutorials/neural_assembly/#Single-spiking-neuron-from-Hodgkin-Huxley-model","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Single spiking neuron from Hodgkin-Huxley model","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig1)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Hodgkin-Huxley (HH) formalism to describe membrane potential of a single neuron","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"  beginalign\n  C_mfracdVdt = -g_L(V-V_L) - g_Nam^3h(V-V_Na) -g_Kn^4(V-V_K) + I_in - I_syn \n  fracdmdt = alpha_m(V)(1-m) + beta_m(V)m \n  fracdhdt = alpha_h(V)(1-h) + beta_h(V)h \n  fracdndt = alpha_n(V)(1-n) + beta_n(V)n\n  endalign","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"using Neuroblox\nusing OrdinaryDiffEq ## to build the ODE problem and solve it, gain access to multiple solvers from this\nusing Random ## for generating random variables\nusing CairoMakie ## for customized plotting recipies for blox\nusing CSV ## to read data from CSV files\nusing DataFrames ## to format the data into DataFrames","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"define a single excitatory neuron 'blox' with steady input current I_bg = 0.5 microA/cm2","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"nn1 = HHNeuronExciBlox(name=Symbol(\"nrn1\"), I_bg=0.5)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"define graph and add the single neuron 'blox' as a single node into the graph","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"g = MetaDiGraph() ## defines a graph\nadd_blox!.(Ref(g), [nn1]) ## adds the defined blocks into the graph","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"create an ODESystem from the graph","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"@named sys = system_from_graph(g)\nlength(unknowns(sys)) ## shows the number of variables in the simplified system","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"To solve the system, we first create an Ordinary Differential Equation Problem and then solve it over the tspan of (0,1e) using a Vern7() solver.  The solution is saved every 0.1ms. The unit of time in Neuroblox is 1ms.","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"prob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"acessing the voltage timeseries from the neuron block and plotting the voltage","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"v = voltage_timeseries(nn1, sol)\n\nfig = Figure();\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Voltage (mv)\")\ncl = get_neuron_color(nn1) #specify color based on neuron type (excitatory/inhibitory)\nlines!(ax, sol.t, v, color=cl)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Suggestion : Try different values of input current 'I_bg' and run the entire code block to see the output activity","category":"page"},{"location":"tutorials/neural_assembly/#Connecting-three-neurons-through-synapses-to-make-a-local-feed-forward-circuit","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Connecting three neurons through synapses to make a local feed-forward circuit","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig2)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"# While creating a system of multiple components (neurons in this case), each component should be defined within the same namespace. So first\n# we define a global namespace.\nglobal_namespace=:g\n\n# define three neurons, two excitatory and one inhibitory\n\nnn1 = HHNeuronExciBlox(name=Symbol(\"nrn1\"), I_bg=0.4,namespace=global_namespace)\nnn2 = HHNeuronInhibBlox(name=Symbol(\"nrn2\"), I_bg=0.1,namespace=global_namespace)\nnn3 = HHNeuronExciBlox(name=Symbol(\"nrn3\"), I_bg=1.4,namespace=global_namespace)\n\n# defien graph and connect the nodes with the edges (synapses in this case), with the synaptic 'weights' specified as arguments\ng = MetaDiGraph()\nadd_edge!(g, nn1 => nn2, weight = 1) ##connection from neuron 1 to neuron 2 (nn1 to nn2)\nadd_edge!(g, nn2 => nn3, weight = 0.2) ##connection from neuron 2 to neuron 3 (nn2 to nn3)\nadd_edge!(g, nn1 => nn3, weight = 0.5) ##connection from neuron 1 to neuron 3 (nn2 to nn3)\n\n# create an ODESystem from the graph and then solve it using an ODE solver\n@named sys = system_from_graph(g)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1);\n\n# plotting membrane voltage activity of all neurons in a stacked form\n\nstackplot([nn1,nn2,nn3],sol)\t## stackplot(<blox or array of blox>, sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Suggestion : Try different values of input currents 'I_bg' and connection weights. One can try different permutations of excitatory and inhibitory neurons.","category":"page"},{"location":"tutorials/neural_assembly/#Creating-a-lateral-inhibition-circuit-(the-\"winner-takes-all\"-circuit)-in-superficial-cortical-layer","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating a lateral inhibition circuit (the \"winner-takes-all\" circuit) in superficial cortical layer","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig3)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\nN_exci = 5; ##number of excitatory neurons\n\nn_inh = HHNeuronInhibBlox(name = Symbol(\"inh\"), namespace=global_namespace, G_syn = 4.0, τ = 70) ##feedback inhibitory interneuron neuron\n\n##creating an array of excitatory pyramidal neurons\nn_excis = [HHNeuronExciBlox(\n                            name = Symbol(\"exci$i\"),\n                            namespace=global_namespace,\n                            G_syn = 3.0,\n                            τ = 5,\n                            I_bg = 5*rand(),\n                            ) for i = 1:N_exci]\n\ng = MetaDiGraph()\n\nfor i in Base.OneTo(N_exci)\n    add_edge!(g, n_inh => n_excis[i], weight = 1.0)\n    add_edge!(g, n_excis[i] => n_inh, weight = 1.0)\nend\n\n@named sys = system_from_graph(g)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1)\nstackplot(vcat(n_excis,n_inh),sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Suggestion : Instead of uniform random input current in each excitatory neuron, try different configurations (random or constant) of input currents I_bg for each neuron. One can vary the size of circuit by changing number of excitatory neurons.","category":"page"},{"location":"tutorials/neural_assembly/#Creating-lateral-inhibition-\"winner-take-all\"-circuit-(WTA)-blocks-from-the-inbuilt-functions-and-connecting-two-WTA-circuit-blocks","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating lateral inhibition \"winner-take-all\" circuit (WTA) blocks from the inbuilt functions and connecting two WTA circuit blocks","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\nN_exci = 5 ##number of excitatory neurons in each WTA circuit\nwta1 = WinnerTakeAllBlox(name=Symbol(\"wta1\"), I_bg=5.0, N_exci=N_exci, namespace=global_namespace) ##for a single valued input current, each neuron of the WTA circuit will recieve a uniformly distributed random input from 0 to I_bg\nwta2 = WinnerTakeAllBlox(name=Symbol(\"wta2\"), I_bg=4.0, N_exci=N_exci, namespace=global_namespace)\n\ng = MetaDiGraph()\nadd_edge!(g, wta1 => wta2, weight=1, density=0.5) ##density keyword sets the connection probability from each excitatory neuron of source WTA circuit to each excitatory neuron of target WTA circuit\n\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1)\n\nneuron_set = get_neurons([wta1,wta2]) ## extract neurons from a composite blocks\nstackplot(neuron_set,sol)","category":"page"},{"location":"tutorials/neural_assembly/#Creating-a-single-cortical-superficial-layer-block-(SCORT-in-Pathak-et.-al.-2024)-by-connecting-multiple-WTA-circuits","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating a single cortical superficial layer block (SCORT in Pathak et. al. 2024) by connecting multiple WTA circuits","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig4)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\nN_wta=10 ## number of WTA circuits\n# parameters\nN_exci=5   ##number of pyramidal neurons in each lateral inhibition (WTA) circuit\nG_syn_exci=3.0 ##maximal synaptic conductance in glutamatergic (excitatory) synapses\nG_syn_inhib=4.0 ## maximal synaptic conductance in GABAergic (inhibitory) synapses from feedback interneurons\nG_syn_ff_inhib=3.5 ## maximal synaptic conductance in GABAergic (inhibitory) synapses from feedforward interneurons\nI_bg=5.0 ##background input\ndensity=0.01 ##connection density between WTA circuits\n\n##creating array of WTA ciruits\nwtas = [WinnerTakeAllBlox(;\n                           name=Symbol(\"wta$i\"),\n                           namespace=global_namespace,\n                           N_exci=N_exci,\n                           G_syn_exci=G_syn_exci,\n                           G_syn_inhib=G_syn_inhib,\n                           I_bg = I_bg\n                          ) for i = 1:N_wta]\n\n##feed-forward interneurons (get input from other pyramidal cells and from the ascending system, largely controls the rhythm)\nn_ff_inh = HHNeuronInhibBlox(;\n                             name=Symbol(\"ff_inh\"),\n                             namespace=global_namespace,\n                             G_syn=G_syn_ff_inhib\n                            )\n\ng = MetaDiGraph()\n\n# connecting WTA circuits to each other with given connection density, and feedforward interneuron connects to each WTA circuit\nfor i in 1:N_wta\n    for j in 1:N_wta\n        if j != i\n            add_edge!(g, wtas[i] => wtas[j], weight=1, density=density)\n        end\n    end\n    add_edge!(g, n_ff_inh => wtas[i], weight=1)\nend\n\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), [])\nsol = solve(prob, Vern7(), saveat=0.1)\n\nneuron_set = get_neurons(vcat(wtas, n_ff_inh)) ## extract neurons from a composite blocks\nstackplot(neuron_set,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Sugestion : try different connection densities and weights and see how it affects the population activity.","category":"page"},{"location":"tutorials/neural_assembly/#Creating-an-ascending-system-block-(ASC1-in-Pathak-et.-al.-2024),-a-single-inbuilt-cortical-superficial-layer-block-(SCORT-in-Pathak-et.-al.-2024)-and-connecting-them.","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating an ascending system block (ASC1 in Pathak et. al. 2024), a single inbuilt cortical superficial layer block (SCORT in Pathak et. al. 2024) and connecting them.","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\n\n# define ascending system block using a Next Generation Neural Mass model as described in Byrne et. al. 2020.\n# the parameters are fixed to generate a 16 Hz modulating frequency in the cortical neurons\n@named ASC1 = NextGenerationEIBlox(;namespace=global_namespace, Cₑ=2*26,Cᵢ=1*26, Δₑ=0.5, Δᵢ=0.5, η_0ₑ=10.0, η_0ᵢ=0.0, v_synₑₑ=10.0, v_synₑᵢ=-10.0, v_synᵢₑ=10.0, v_synᵢᵢ=-10.0, alpha_invₑₑ=10.0/26, alpha_invₑᵢ=0.8/26, alpha_invᵢₑ=10.0/26, alpha_invᵢᵢ=0.8/26, kₑₑ=0.0*26, kₑᵢ=0.6*26, kᵢₑ=0.6*26, kᵢᵢ=0*26)\n\n# define the superficial layer cortical block using inbuilt function\n# Number if WTA circuits = N_wta=45; number of pyramidal neurons in each WTA circuit = N_exci = 5;\n@named CB = CorticalBlox(N_wta=10, N_exci=5, density=0.01, weight=1,I_bg_ar=7;namespace=global_namespace)\n\n# define graph and connect ASC1->CB\ng = MetaDiGraph()\nadd_edge!(g, ASC1 => CB, weight=44)\n\n# solve the system for time 0 to 1000 ms\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), []) ## tspan = (0,1000)\nsol = solve(prob, Vern7(), saveat=0.1);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot neuron time series","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"neuron_set = get_neurons(CB) ## extract neurons from a composite block like CorticalBlox\nn_neurons = 50 ## set number nof neurons to display in the stackplot\nstackplot(neuron_set[1:n_neurons],sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot the meanfield of all cortical block neurons (mean membrane voltage)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"mnv = meanfield_timeseries(CB, sol)\nfig = Figure();\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Meanfield voltage (mv)\")\nlines!(ax, sol.t, mnv)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot power spectrum of the meanfield (average over membrane potentials)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"powerspectrumplot(CB,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Notice the peak at 16 Hz, representing beta oscillations. Sugestion : try changing parameters of ASC1 to generate different cortical rhythms. See how the peak shifts in the powerspectrum","category":"page"},{"location":"tutorials/neural_assembly/#Creating-simulation-of-visual-stimulus-response-in-cortical-blocks","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Creating simulation of visual stimulus response in cortical blocks","text":"","category":"section"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"(Image: fig5) create cortical blocks for visual area cortex (VAC), anterior cortex (AC) and ascending system block (ASC1)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"global_namespace=:g\n# cortical blox\n@named VAC = CorticalBlox(N_wta=10, N_exci=5,  density=0.01, weight=1,I_bg_ar=0;namespace=global_namespace)\n@named AC = CorticalBlox(N_wta=10, N_exci=5, density=0.01, weight=1,I_bg_ar=0;namespace=global_namespace)\n# ascending system blox, modulating frequency set to 16 Hz\n@named ASC1 = NextGenerationEIBlox(;namespace=global_namespace, Cₑ=2*26,Cᵢ=1*26, Δₑ=0.5, Δᵢ=0.5, η_0ₑ=10.0, η_0ᵢ=0.0, v_synₑₑ=10.0, v_synₑᵢ=-10.0, v_synᵢₑ=10.0, v_synᵢᵢ=-10.0, alpha_invₑₑ=10.0/26, alpha_invₑᵢ=0.8/26, alpha_invᵢₑ=10.0/26, alpha_invᵢᵢ=0.8/26, kₑₑ=0.0*26, kₑᵢ=0.6*26, kᵢₑ=0.6*26, kᵢᵢ=0*26)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"create an image source block which takes image data from a .csv file and gives input to visual cortex","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"fn = joinpath(@__DIR__, \"../data/image_example.csv\") ## image data file\nimage_set = CSV.read(fn, DataFrame) ## reading data into DataFrame format\nimage_sample = 2 ## set which image to input (from 1 to 1000)\n\n# define stimulus source blox\n# t_stimulus: how long the stimulus is on (in msec)\n# t_pause : how long th estimulus is off (in msec)\n@named stim = ImageStimulus(image_set[[image_sample],:]; namespace=global_namespace, t_stimulus=1000, t_pause=0);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"plot the image that the visual cortex 'sees'","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"pixels=Array(image_set[image_sample,1:end-1])## access the desired image sample from respective row\npixels=reshape(pixels,15,15)## reshape into 15 X 15 square image matrix\nheatmap(pixels,colormap = :gray1) #input image matrix seen as heatmap","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"assemble the blox into a graph and set connections with their keword arguments like connection weight and connection density","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"g = MetaDiGraph()\n\nadd_edge!(g, stim => VAC, weight=14)\nadd_edge!(g, ASC1 => VAC, weight=44)\nadd_edge!(g, ASC1 => AC, weight=44)\nadd_edge!(g, VAC => AC, weight=3, density=0.08)\n\n# define odesystem and solve\nsys = system_from_graph(g, name=global_namespace)\nprob = ODEProblem(sys, [], (0.0, 1000), []) ## tspan = (0,1000)\nsol = solve(prob, Vern7(), saveat=0.1);\nnothing #hide","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Let us now plot neuron potentials, meanfield activity and powerspectrums for the VAC and AC blox. First we show the stackplot of voltage potentials from the first 10 neurons of VAC","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"VAC_neuron_set = get_neurons(VAC) ## extract neurons from VAC\nn_neurons = 40 ##number of neurons displayed. You can try incresing it.\nstackplot(VAC_neuron_set[1:n_neurons],sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"then we plot the meanfield potential out of all neurons within VAC","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"mnv = meanfield_timeseries(VAC, sol)\n\nfig = Figure();\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Voltage (mv)\")\nlines!(ax, sol.t, mnv)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Here is the powerspectrum from all neurons within VAC","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"powerspectrumplot(VAC,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Moving on to the AC blox, we first plot the voltage potential of its neurons","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"AC_neuron_set = get_neurons(AC) ## extract neurons from VAC\nn_neurons = 40\nstackplot(AC_neuron_set[1:n_neurons],sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"followed by the meanfield activity","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"mnv = meanfield_timeseries(AC,sol)\nfig = Figure();\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Voltage (mv)\")\nlines!(ax, sol.t, mnv)\nfig ## to display the figure","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"and finally the AC powerspectrum","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"powerspectrumplot(AC,sol)","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"Sugestion : Try changing the image samples and notice the change in the spatial firing patterns in VAC and AC neurons. One can make multiple cortical blocks simillar to AC and connect them in various connection topologies. All of them can directly or indirectly get input from VAC.","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"","category":"page"},{"location":"tutorials/neural_assembly/","page":"Tutorial on bottom-up approach to building a neural assembly","title":"Tutorial on bottom-up approach to building a neural assembly","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"EditURL = \"ping_network.jl\"","category":"page"},{"location":"tutorials/ping_network/#Pyramidal-Interneuron-Gamma-network","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"","category":"section"},{"location":"tutorials/ping_network/#Introduction","page":"Pyramidal-Interneuron Gamma network","title":"Introduction","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"This tutorial provides a simple example of how to use the Neuroblox package to simulate a pyramidal-interneuron gamma (PING) network. These networks are generally useful in modeling cortical oscillations and are used in a variety of contexts. This particular example is based on Börgers, Epstein, and Kopell [1] and is a simple example of how to replicate their initial network in Neuroblox.","category":"page"},{"location":"tutorials/ping_network/#Conceptual-definition","page":"Pyramidal-Interneuron Gamma network","title":"Conceptual definition","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"The PING network is a simple model of a cortical network that consists of two populations of neurons: excitatory and inhibitory. We omit the detailed equations of the neurons here, but note they are Hodgkin-Huxley-like equations with a few modifications. Excitatory neurons are reduced Traub-Miles cells [2] and inhibitory neurons are Wang-Buzasaki cells [3]. Both follow Hodgkin-Huxley formalism, i.e., the membrane voltage is governed by the sum of the currents through the sodium, potassium, and leak channels, along with external drive, such that:","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"beginequation*\nC fracdVdt = g_textNa m^3 h (V_textNa - V) + g_textK n^4 (V_textK - V) + g_textL (V_textL - V) + I_textext\nendequation*","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"For full details of the model, see Eq. 12-14 on p. 7 of the SI Appendix of Börgers et al. [1]. Here is a visual representation of the network structure and which neurons receive the driving input: (Image: PING network structure)","category":"page"},{"location":"tutorials/ping_network/#Model-setup","page":"Pyramidal-Interneuron Gamma network","title":"Model setup","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"This section sets up the model parameters and the network structure. The network consists of 200 neurons: 40 driven excitatory neurons, 120 other excitatory neurons, and 40 inhibitory neurons. The network is set up as a directed graph with excitatory neurons driving inhibitory neurons and vice versa, with self-inhibition but not self-excitation present.","category":"page"},{"location":"tutorials/ping_network/#Import-the-necessary-packages","page":"Pyramidal-Interneuron Gamma network","title":"Import the necessary packages","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Reasons for each non-Neuroblox package are given in the comments after each.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"using Neuroblox\nusing OrdinaryDiffEq ## to build the ODE problem and solve it, gain access to multiple solvers from this\nusing Distributions ## for statistical distributions\nusing Random ## for random number generation\nusing CairoMakie ## for plotting","category":"page"},{"location":"tutorials/ping_network/#Initialization","page":"Pyramidal-Interneuron Gamma network","title":"Initialization","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Set the random seed to reproduce the plots as shown here exactly. If you want to probe how random variability changes the network, simply omit this line.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Random.seed!(42);\nnothing #hide","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Setup the hyperparameters for the PING network simulation. The comments note where these parameters are taken from in the Börgers et al. paper [1] or if they were manually tuned for this particular simulation.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"μ_E = 0.8 ## mean of the excitatory neurons' external current, manually tuned from the value on p. 8 of the Appendix\nσ_E = 0.15 ## standard deviation of the excitatory neurons' external current, given on p. 8 of the Appendix\nμ_I = 0.8 ## mean of the inhibitory neurons' external current, given on p. 9 of the Appendix\nσ_I = 0.08 ## standard deviation of the inhibitory neurons' external current, given on p. 9 of the Appendix\n\nNE_driven = 40 ## number of driven excitatory neurons, given on p. 8 of the Appendix. Note all receive constant rather than half stochastic drives.\nNE_other = 120 ## number of non-driven excitatory neurons, given in the Methods section\nNI_driven = 40 ## number of inhibitory neurons (all driven), given in the Methods section\nN_total = NE_driven + NE_other + NI_driven ## total number of neurons in the network\n\nN = N_total ## convenience redefinition to improve the readability of the connection weights\ng_II = 0.2 ## inhibitory-inhibitory connection weight, given on p. 8 of the Appendix\ng_IE = 0.6 ## inhibitory-excitatory connection weight, given on p. 8 of the Appendix\ng_EI = 0.8; ## excitatory-inhibitory connection weight, manually tuned from values given on p. 8 of the Appendix\nnothing #hide","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Finally, setup the driving currents. All neurons receive a base external current, and the inhibitory and driven excitatory populations receive a second external stimulus current. The undriven excitatory neurons receive a small addition to the base current in lieu of the stochastic current in the original implementation. There is also an external inhibitory bath for the inhibitory neurons - for the importance of this bath see the SI Appendix of Börgers et al. [1].","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"I_base = Normal(0, 0.1) ## base external current for all neurons\nI_driveE = Normal(μ_E, σ_E) ## External current for driven excitatory neurons\nI_driveI = Normal(μ_I, σ_I) ## External current for driven inhibitory neurons\nI_undriven = Normal(0, 0.4) ## Additional noise current for undriven excitatory neurons. Manually tuned.\nI_bath = -0.7; ## External inhibitory bath for inhibitory neurons - value from p. 11 of the SI Appendix\nnothing #hide","category":"page"},{"location":"tutorials/ping_network/#Creating-a-network-in-Neuroblox","page":"Pyramidal-Interneuron Gamma network","title":"Creating a network in Neuroblox","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Creating and running a network of neurons in Neuroblox consists of three steps: defining the neurons, defining the graph of connections between the neurons, and simulating the system represented by the graph.","category":"page"},{"location":"tutorials/ping_network/#Define-the-neurons","page":"Pyramidal-Interneuron Gamma network","title":"Define the neurons","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"The neurons from Börgers et al. [1] are implemented in Neuroblox as PINGNeuronExci and PINGNeuronInhib. We can specify their initial current drives and create the neurons as follows:","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"exci_driven = [PINGNeuronExci(name=Symbol(\"ED$i\"), I_ext=rand(I_driveE) + rand(I_base)) for i in 1:NE_driven] ## In-line loop to create the driven excitatory neurons, named ED1, ED2, etc.\nexci_other  = [PINGNeuronExci(name=Symbol(\"EO$i\"), I_ext=rand(I_base) + rand(I_undriven)) for i in 1:NE_other] ## In-line loop to create the undriven excitatory neurons, named EO1, EO2, etc.\nexci        = [exci_driven; exci_other] ## Concatenate the driven and undriven excitatory neurons into a single vector for convenience\ninhib       = [PINGNeuronInhib(name=Symbol(\"ID$i\"), I_ext=rand(I_driveI) + rand(I_base) + I_bath) for i in 1:NI_driven]; ## In-line loop to create the inhibitory neurons, named ID1, ID2, etc.\nnothing #hide","category":"page"},{"location":"tutorials/ping_network/#Define-the-graph-of-network-connections","page":"Pyramidal-Interneuron Gamma network","title":"Define the graph of network connections","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"This portion illustrates how we go about creating a network of neuronal connections.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"g = MetaDiGraph() ## Initialize the graph\n\n# Add the E -> I and I -> E connections\nfor ne ∈ exci\n    for ni ∈ inhib\n        add_edge!(g, ne => ni; weight=g_EI/N)\n        add_edge!(g, ni => ne; weight=g_IE/N)\n    end\nend\n\n# Add the I -> I connections\nfor ni1 ∈ inhib\n    for ni2 ∈ inhib\n        add_edge!(g, ni1 => ni2; weight=g_II/N);\n    end\nend","category":"page"},{"location":"tutorials/ping_network/#Simulate-the-network","page":"Pyramidal-Interneuron Gamma network","title":"Simulate the network","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Now that we have the neurons and the graph, we can simulate the network. We use the system_from_graph function to create a system of ODEs from the graph and then solve it using the DifferentialEquations.jl package, but for performance scaling reasons we will use the experimental option graphdynamics=true which uses a separate compilation backend called GraphDynamics.jl. The GraphDynamics.jl backend is still experimental, and may not yet support all of the standard Neuroblox features, such as those seen in the Spectral DCM tutorial.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"tspan = (0.0, 300.0) ## Time span for the simulation - run for 300ms to match the Börgers et al. [1] Figure 1.\n@named sys = system_from_graph(g, graphdynamics=true) ## Use GraphDynamics.jl otherwise this can be a very slow simulation\nprob = ODEProblem(sys, [], tspan) ## Create the problem to solve\nsol = solve(prob, Tsit5(), saveat=0.1); ## Solve the problem and save at 0.1ms resolution.\nnothing #hide","category":"page"},{"location":"tutorials/ping_network/#Plotting-the-results","page":"Pyramidal-Interneuron Gamma network","title":"Plotting the results","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Now that we have a whole simulation, let's plot the results and see how they line up with the original figures. We're looking to reproduce the dynamics shown in Figure 1 of Börgers et al. [1]. To create raster plots in Neuroblox for the excitatory and inhibitory populations, it is as simple as:","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"fig = Figure()\nrasterplot(fig[1,1], exci, sol; threshold=20.0, title=\"Excitatory Neurons\")\nrasterplot(fig[2,1], inhib, sol; threshold=20.0, title=\"Inhibitory Neurons\")\nfig","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"The upper panel should show the dynamics in Figure 1.C, with a clear population of excitatory neurons firing together from the external driving current, and the other excitatory neurons exhibiting more stochastic bursts. The lower panel should show the dynamics in Figure 1.A, with the inhibitory neurons firing in a more synchronous manner than the excitatory neurons.","category":"page"},{"location":"tutorials/ping_network/#Conclusion","page":"Pyramidal-Interneuron Gamma network","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"And there you have it! A complete PING demonstration that reproduces the dynamics of a published paper in a matter of 30 seconds, give or take. Have fun making your own!","category":"page"},{"location":"tutorials/ping_network/#References","page":"Pyramidal-Interneuron Gamma network","title":"References","text":"","category":"section"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"Börgers C, Epstein S, Kopell NJ. Gamma oscillations mediate stimulus competition and attentional selection in a cortical network model. Proc Natl Acad Sci U S A. 2008 Nov 18;105(46):18023-8. DOI: 10.1073/pnas.0809511105.\nTraub, RD, Miles, R. Neuronal Networks of the Hippocampus. Cambridge University Press, Cambridge, UK, 1991.\nWang, X-J, Buzsáki, G. Gamma oscillation by synaptic inhibition in a hippocampal interneuronal network model. J. Neurosci., 16:6402–6413, 1996.","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"","category":"page"},{"location":"tutorials/ping_network/","page":"Pyramidal-Interneuron Gamma network","title":"Pyramidal-Interneuron Gamma network","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Neuroblox","page":"Neuroblox","title":"Neuroblox","text":"","category":"section"},{"location":"#About","page":"Neuroblox","title":"About","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"Neuroblox.jl is designed for computational neuroscience and psychiatry applications. Our tools range from control circuit system identification to brain circuit simulations bridging scales from spiking neurons to fMRI-derived circuits, parameter-fitting models to neuroimaging data, interactions between the brain and other physiological systems, experimental optimization, and scientific machine learning.","category":"page"},{"location":"#Description","page":"Neuroblox","title":"Description","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"Neuroblox.jl is based on a library of modular computational building blocks (“blox”) in the form of systems of symbolic dynamic differential equations that can be combined to describe large-scale brain dynamics.  Once a model is built, it can be simulated efficiently and fit electrophysiological and neuroimaging data.  Moreover, the circuit behavior of multiple model variants can be investigated to aid in distinguishing between competing hypotheses. We employ ModelingToolkit.jl to describe the dynamical behavior of blox as symbolic (stochastic/delay) differential equations.  Our libraries of modular blox consist of individual neurons (Hodgkin-Huxley, IF, QIF, LIF, etc.), neural mass models (Jansen-Rit, Wilson-Cowan, Lauter-Breakspear, Next Generation, microcanonical circuits etc.) and biomimetically-constrained control circuit elements.  A GUI designed to be intuitive to neuroscientists allows researchers to build models that automatically generate high-performance systems of numerical ordinary/stochastic differential equations from which one can run stimulations with parameters fit to experimental data.  Our benchmarks show that the increase in speed for simulation often exceeds a factor of 100 as compared to neural mass model implementation by the Virtual Brain (python) and similar packages in MATLAB.  For parameter fitting of brain circuit dynamical models, we use Turing.jl to perform probabilistic modeling, including Hamilton-Monte-Carlo sampling and Automated Differentiation Variational Inference.","category":"page"},{"location":"#Installation","page":"Neuroblox","title":"Installation","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"To install Neuroblox.jl, first add the JuliaHubRegistry and then use the Julia package manager:","category":"page"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"using Pkg\nPkg.add(\"PkgAuthentication\")\nusing PkgAuthentication\nPkgAuthentication.install(\"juliahub.com\")\nPkg.Registry.add()\nPkg.add(\"Neuroblox\")","category":"page"},{"location":"#Licensing","page":"Neuroblox","title":"Licensing","text":"","category":"section"},{"location":"","page":"Neuroblox","title":"Neuroblox","text":"Neuroblox is free for non-commerical and academic use. For full details of the license, please see  the Neuroblox EULA. For commercial use, get in contact with sales@neuroblox.org.","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"EditURL = \"resting_state.jl\"","category":"page"},{"location":"tutorials/resting_state/#Resting-state-simulation-using-neural-mass-models","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"","category":"section"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"This tutorial will introduce you to simulating resting state brain dynamics using Neuroblox. We will be using the FitzHugh-Nagumo model as a building block. The FitzHugh-Nagumo model is described by the follwoing equations:","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"       beginalign\n       dotV = d  tau (-f V^3 + e V^2 + alpha W - gamma I_c + sigma w(t) ) \n       dotW = dfracdtau(b V - beta W + a + sigma w(t) )\n       endalign","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"We start by building the resting state circuit from individual Generic2dOscillator Blox","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"using Neuroblox\nusing CSV\nusing DataFrames\nusing StochasticDiffEq\nusing Random\nusing CairoMakie\nusing Statistics\nusing HypothesisTests\n\n# read connection matrix from file\nweights = CSV.read(\"../data/weights.csv\",DataFrame)\nregion_names = names(weights)\n\nwm = Array(weights) ## transform the weights into a matrix\nN_bloxs = size(wm)[1] ## number of blox components\n\n# create an array of neural mass models\nblocks = [Generic2dOscillator(name=Symbol(region_names[i]),bn=sqrt(5e-4)) for i in 1:N_bloxs]\n\n# add neural mass models to Graph and connect using the connection matrix\ng = MetaDiGraph()\nadd_blox!.(Ref(g), blocks)\ncreate_adjacency_edges!(g, wm)\n\n@named sys = system_from_graph(g);\nnothing #hide","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"To solve the system, we first create an Stochastic Differential Equation Problem and then solve it using a EulerHeun solver. The solution is saved every 0.5 ms. The unit of time in Neuroblox is 1 ms.","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"prob = SDEProblem(sys,rand(-2:0.1:4,76*2), (0.0, 6e5), [])\nsol = solve(prob, EulerHeun(), dt=0.5, saveat=5)","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"Let us plot the voltage potential of the first couple of components","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"v1 = voltage_timeseries(blocks[1], sol)\nv2 = voltage_timeseries(blocks[2], sol)\n\nfig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time (ms)\", ylabel = \"Potential\")\nlines!(ax, sol.t, v1)\nlines!(ax, sol.t, v2)\nxlims!(ax, (0, 1000)) ## limit the x-axis to the first second of simulation\nfig","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"To evaluate the connectivity of our simulated resting state network, we calculate the statistically significant correlations","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"cs = []\nfor i in 1:Int((length(sol.t)-1)/1000)-1\n    solv = Array(sol[1:2:end,(i-1)*1000+1:(i*1000)])'\n    push!(cs,cor(solv))\nend\ncss = stack(cs)\n\np = zeros(76,76)\nfor i in 1:76\n    for j in 1:76\n        p[i,j] = pvalue(OneSampleTTest(css[i,j,:]))\n    end\nend\n\nheatmap(log10.(p) .* (p .< 0.05))","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"Fig.: log10(p value) displaying statistally significant correlation between time series","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"heatmap(wm)","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"Fig.: Connection Adjacency Matrix that was used to connect the neural mass models","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"","category":"page"},{"location":"tutorials/resting_state/","page":"Resting state simulation using neural mass models","title":"Resting state simulation using neural mass models","text":"This page was generated using Literate.jl.","category":"page"}]
}
